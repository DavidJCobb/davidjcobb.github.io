---
title: Ray/cone intersections
tags:
 - 3D
 - geometry
 - intersection
 - math
 - raycasting
social_media:
   description: The math behind doing raycasts for 3D cones, with the mathematical derivation fully explained step, by step. Includes public-domain code.
extra_css_files:
 - lu-math.css
table_of_contents:
 - id:    parametric
   title: Parametric surface of a cone
 - id:    implicit
   title: Implicit surface of a cone
 - id:    transformed
   title: Handling a translated and rotated cone
 - id:    solving
   title: Solving for the ray
 - id:    free-code
   title: Free code!
   
---
{%- include lu-math/defines.html -%}

{%- assign var_Ca     = "<var data-type='vector'>C<sub>a</sub></var>" -%}
{%- assign var_Cb     = "<var data-type='vector'>C<sub>b</sub></var>" -%}
{%- assign var_Ch     = "<var>C<sub>h</sub></var>" -%}
{%- assign var_Cq     = "<var>C<sub>q</sub></var>" -%}
{%- assign var_Cr     = "<var>C<sub>r</sub></var>" -%}
{%- assign var_Cs     = "<var data-type='vector'>C<sub>s</sub></var>" -%}
{%- assign var_Ct     = "<var data-type='vector'>C<sub>t</sub></var>" -%}
{%- assign var_Hd     = "<var>H<sub>d</sub></var>" -%}
{%- assign var_Hn     = "<var data-type='vector'>H<sub>n</sub></var>" -%}
{%- assign var_Ho     = "<var>H<sub>o</sub></var>" -%}
{%- assign var_Hp     = "<var data-type='vector'>H<sub>p</sub></var>" -%}
{%- assign var_Hs     = "<var data-type='vector'>H<sub>s</sub></var>" -%}
{%- assign var_Rd     = "<var data-type='vector'>R<sub>d</sub></var>" -%}
{%- assign var_Rl     = "<var data-type='vector'>R<sub>l</sub></var>" -%}
{%- assign var_Ro     = "<var data-type='vector'>R<sub>o</sub></var>" -%}
{%- assign var_Vz     = "<var data-type='vector'>V<sub>z</sub></var>" -%}
{%- assign var_Ca_inl = var_Ca | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Cb_inl = var_Cb | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Ch_inl = var_Ch | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Cr_inl = var_Cr | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Cs_inl = var_Cs | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Ct_inl = var_Ct | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Hd_inl = var_Hd | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Hn_inl = var_Hn | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Ho_inl = var_Ho | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Hp_inl = var_Hp | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Hs_inl = var_Hs | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Rd_inl = var_Rd | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Rl_inl = var_Rl | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Ro_inl = var_Ro | prepend: math_inl_enter | append: math_inl_leave -%}

{%- capture graph_rel_url -%}
   {%- comment -%}
      We want to strip the file extension off of the path to this current article, if it 
      has one (this will depend on the permalink).
   {%- endcomment -%}
   {%- assign temporary = page.url | relative_url | split: "." -%}
   {{- page.dir -}}
   {%- if temporary.size > 1 -%}
      {%- for item in temporary -%}
         {%- unless forloop.last -%}{{ item }}{%- endunless -%}
      {%- endfor -%}
   {%- else -%}
      {{ temporary[0] }}
   {%- endif -%}
   {%- comment -%}
      Next, we add the name of the asset file we want.
   {%- endcomment -%}
   /line-graph-utils.svg
{%- endcapture -%}
{%- assign graph_rel_url = graph_rel_url -%}

<section>
   <p>
      There are a lot of people out on the web who are willing to share raycasting code, but not a whole lot of them bother to actually apply a permissive license to it so that people can legally use it. What's more, a lot of them don't explain how they actually derived the math involved either.
   </p>
   <p>
      Here, I'm going to walk through how to put together a ray/cone intersection test. I've also provided code at the bottom as a public domain work.
   </p>
</section>

<section>
   <h2><a name="parametric"></a>Parametric surface of a cone</h2>
   <p>
      The parametric equations (that is, equations with parameters) for a cone are as follows:
   </p>
   <lu-math>
      <m-givens>
         <label>Given:</label>
         <dl>
            <dt>{{var_Ch}}</dt>
            <m-sep> = </m-sep>
               <dd>height of the cone</dd>
            <dt>{{var_Cr}}</dt>
            <m-sep> = </m-sep>
               <dd>radius of the cone's base</dd>
            <dt>{{var_Ho}}</dt>
            <m-sep> = </m-sep>
               <dd>height offset on the range [0, {{var_Ch}}], where 0 is aligned with the cone's base</dd>
            <dt><var>&theta;</var></dt>
            <m-sep> = </m-sep>
               <dd>any angle, basically</dd>
         </dl>
      </m-givens>
      <m-layout-left>
         {{lu_math_eq_numbers[1]}}
         
         <m-row>
            <m-function-def>
               <m-name>f<sub>x</sub></m-name><!--
            --><m-args><!--
               --><m-delim>(</m-delim>
                     <m-arg>{{var_Ho}}</m-arg>
                  <m-sep>, </m-sep>
                     <m-arg><var>&theta;</var></m-arg>
                  <m-delim>)</m-delim><!--
            --></m-args>
            </m-function-def>
            =
            <m-fraction>
               <m-raw>(</m-raw>
               <m-numer>{{var_Ch}} - {{var_Ho}}</m-numer>
               <m-raw>) &divide; </m-raw>
               <m-denom>{{var_Ch}}</m-denom>
            </m-fraction>
            <m-raw> &times; </m-raw>
            {{var_Cr}}
            &times;
            cos(<var>&theta;</var>)
         </m-row>
         <m-row>
            <m-function-def>
               <m-name>f<sub>y</sub></m-name><!--
            --><m-args><!--
               --><m-delim>(</m-delim>
                     <m-arg>{{var_Ho}}</m-arg>
                  <m-sep>, </m-sep>
                     <m-arg><var>&theta;</var></m-arg>
                  <m-delim>)</m-delim><!--
            --></m-args>
            </m-function-def>
            =
            <m-fraction>
               <m-raw>(</m-raw>
               <m-numer>{{var_Ch}} - {{var_Ho}}</m-numer>
               <m-raw>) &divide; </m-raw>
               <m-denom>{{var_Ch}}</m-denom>
            </m-fraction>
            <m-raw> &times; </m-raw>
            {{var_Cr}}
            &times;
            sin(<var>&theta;</var>)
         </m-row>
         <m-row>
            <m-function-def>
               <m-name>f<sub>z</sub></m-name><!--
            --><m-args><!--
               --><m-delim>(</m-delim>
                     <m-arg>{{var_Ho}}</m-arg>
                  <m-sep>, </m-sep>
                     <m-arg><var>&theta;</var></m-arg>
                  <m-delim>)</m-delim><!--
            --></m-args>
            </m-function-def>
            =
            {{var_Ho}}
         </m-row>
      </m-layout-left>
   </lu-math>
   <p>
      Technically, these equations describe an infinite cone &mdash; one with no endcap, which extends forever in both directions. (Yes, both. When you go above the tip, the cone turns inside out and starts widening again.) However, we can still use them to put together the tests for a finite cone with an endcap.
   </p>

   <aside>
      <p>
         The above equation works if you imagine the cone viewed from two perpendicular angles. Let's start with a 2D cross-section of the cone as seen from the side. 
      </p>
      <figure class="card-cutout mathematical-graph">
         <svg class="graph" viewBox="-5 -5 10 10" xmlns="http://www.w3.org/2000/svg" width="200" height="200"
            alt="A 2D graph showing a cone as seen from the side: it is two lines extending rightward from the origin. One increases slightly; the other decreases slightly by the same amount, dipping into the negative half of the graph."
         >
            <use href="{{graph_rel_url}}#ready-made-grid" x="0" y="0" />
            
            <line x1="0" y1="0" x2="5" y2="-2.5" stroke="#8000FF" stroke-width="4" stroke-linecap="round" vector-effect="non-scaling-stroke" />
            <line x1="0" y1="0" x2="5" y2=" 2.5" stroke="#8000FF" stroke-width="4" stroke-linecap="round" vector-effect="non-scaling-stroke" />
         </svg>
      </figure>
      <p>
         Think about getting the slope of a line on a line graph: {{var_Ysca_inl}} divided by {{var_Xsca_inl}}. For a cross-section of the cone, with the tip at <lu-math data-inline>(0, 0)</lu-math> and the base towards the right, the cone's surface would be a line that passes through (and terminates at) <lu-math data-inline>({{var_Ch}}, {{var_Cr}})</lu-math>. The equation for this line would therefore be:
      </p>
      <lu-math>
         {{lu_math_eq_numbers[2]}}
         
         <var>y</var>
         =
         <m-raw>(</m-raw><!--
      -->{%- include lu-math/fraction.html
            numer=var_Cr
            denom=var_Ch
         -%}<!--
      --><m-raw>)</m-raw>
         <var>x</var>
      </lu-math>
      <p>
         We can check this with a simple test: the point <lu-math data-inline>(5, 10)</lu-math> is on the line <lu-math data-inline>{{var_Ysca}} = 2{{var_Xsca}}</lu-math>, and so:
      </p>
      <lu-math>
         {{var_Ysca}}
         =
         <m-raw>(</m-raw><!--
      -->{%- include lu-math/fraction.html
            numer="10"
            denom="5"
         -%}<!--
      --><m-raw>)</m-raw>
         {{var_Xsca}}
         =
         2{{var_Xsca}}
      </lu-math>
      <p>
         And this all makes sense, right? The cone doesn't curve or bend; pick any point along the edge of the cone's base, and you can connect that point to the cone's tip with a straight line. The length of that line will be proportional to the cone's radius and height. That explains the fractions in the equations for <lu-math data-inline><b>f</b><sub><var>x</var></sub></lu-math> and <lu-math data-inline><b>f</b><sub><var>y</var></sub></lu-math>.
      </p>
      <p>
         Let's focus next on a 2D view of our cone along its main axis. The result is, 
         naturally, a circle:
      </p>
      <figure class="card-cutout mathematical-graph">
         <svg class="graph" viewBox="-5 -5 10 10" xmlns="http://www.w3.org/2000/svg" width="200" height="200"
            alt="A 2D graph showing a cone as seen from above or below. It is a circle."
         >
            <use href="{{graph_rel_url}}#ready-made-grid" x="0" y="0" />
            
            <circle cx="0" cy="0" r="3"  stroke="#8000FF" stroke-width="4" stroke-linecap="round" fill="transparent" vector-effect="non-scaling-stroke" />
         </svg>
      </figure>
      <p>
         That's where <lu-math data-inline><var>&theta;</var></lu-math> and the sine and cosine functions come in. Scale those by {{var_Cr_inl}} and we get the coordinates of the edge of the cone's base.
      </p>
      <p>
         We know that given any point <lu-math data-inline>({{var_Xsca}}, {{var_Ysca}})</lu-math>, the distance from that point to the circle's boundary will be given by:
      </p>
      <lu-math>
         {{ lu_math_raw_endcap -}}
         {%- capture temporary -%}
            {{var_Xsca}}{{lu_math_sq}} + {{var_Ysca}}{{lu_math_sq}}
         {%- endcapture -%}
         {%- include lu-math/sqrt.html content=temporary -%}
         {{- lu_math_raw_endcap -}}
      </lu-math>
      <p>
         Therefore, a point lies on the circle's boundary if, given the radius {{var_Cr_inl}}, the following expression is true:
      </p>
      <lu-math>
         {{ lu_math_raw_endcap -}}
         {%- capture temporary -%}
            <var>x</var>{{lu_math_sq}} + <var>y</var>{{lu_math_sq}}
         {%- endcapture -%}
         {%- include lu-math/sqrt.html content=temporary %}
         =
         {{var_Cr}}
      </lu-math>
      <p>
         Of course, we don't need the square root operation:
      </p>
      <lu-math>
         {{lu_math_eq_numbers[3]}}
         
         <var>x</var>{{lu_math_sq}} + <var>y</var>{{lu_math_sq}}
         =
         {{var_Cr}}{{lu_math_sq}}
      </lu-math>
      <p>
         So how do we take these two views and create a 3D cone with them? Well, for simplicity's sake, let's say that our cone's base is centered on the world origin <lu-math data-inline><m-nobr>(0, 0, 0)</m-nobr></lu-math> and aligned with the XY plane &mdash; so the cone points upward on the Z-axis. For now, we just want to explore some basic facts and relationships about points on cones, and anchoring the cone at that place and orientation will simplify the math involved.
      </p>
      <p>
         There are a few observations we can make about the first graph:
      </p>
      <ul>
         <li>
            Suppose we relabel our axes to reflect our use of a 3D cone: we are now graphing {{var_Xsca_inl}} and {{var_Zsca_inl}}. This means that the first graph depicts our cone shifted by <lu-math data-inline>-{{var_Ch}}</lu-math>.
         </li>
         <li>
            Suppose we relabel our axes a different way: we're graphing {{var_Ysca_inl}} and {{var_Zsca_inl}}. The graph looks identical!
         </li>
      </ul>
      <p>
         This means that {{var_Xsca_inl}} and {{var_Ysca_inl}} have the same relationship with {{var_Zsca_inl}}. If we look at the definitions of <lu-math data-inline><b>f<sub><var>x</var></sub></b></lu-math> and <lu-math data-inline><b>f<sub><var>y</var></sub></b></lu-math>, we see that the only difference between {{var_Xsca_inl}} and {{var_Ysca_inl}} &mdash; the thing that <em>makes</em> one of them {{var_Xsca_inl}} and the other one {{var_Ysca_inl}} &mdash; is our choice of trigonometric function. Therefore, the rest of that equation must define their relationship with {{var_Zsca_inl}}. And indeed, if the cone's base is at <lu-math data-inline>(0,&nbsp;0,&nbsp;0)</lu-math> and its height is measured along the Z-axis, then {{var_Zsca_inl}} must be the offset-height, {{var_Ho_inl}}.
      </p>
   </aside>
</section>

<section>
   <h2><a name="implicit">Implicit surface of a cone</a></h2>
   <p>
      At the top of this page, we define a cone as a <dfn>parametric surface</dfn> &mdash; that is, we have three <dfn>parametric equations</dfn> (equations that take parameters) which define all points on the surface of the cone. However, if we can come up with an <dfn>implicit surface</dfn> &mdash; that is, a surface defined by a single equation, wherein {{var_Xsca_inl}}, {{var_Ysca_inl}}, and {{var_Zsca_inl}} are on one side, and 0 is on the other side &mdash; then we can use vector math to deal with the cone more easily.
   </p>
   <p>
      We know from our exploration above that at the cone's base, a point lies on the cone's surface (the edge of the base) if Equation 3 is true. We can represent that equation in terms of any arbitrary 2D vector <lu-math data-inline><var data-type="vector">P</var></lu-math>:
   </p>
   <lu-math>
      <m-row>
         {{lu_math_eq_numbers[4]}}
         
         {{lu_math_vec_start}}{{var_Pvec}}{{lu_math_vec_end}}
         =
         {{var_Cr}}
      </m-row>
   </lu-math>
   <p>
      We also know that as we move further along the cone's height, to its tip, the radius shrinks proportional to the cone's height. Therefore:
   </p>
   <lu-math>
      {{var_Xsca}}{{lu_math_sq}} + {{var_Ysca}}{{lu_math_sq}}
      =
      <m-fraction>
         <m-numer>{{var_Cr}}</m-numer>
         <m-raw> &divide; (</m-raw>
         <m-denom>{{var_Ch}} - {{var_Zsca}}</m-denom>
         <m-raw>)</m-raw>
      </m-fraction>
      {{- lu_math_raw_endcap -}}
   </lu-math>
</section>

<section>
   <h2><a name="transformed">Handling a translated and rotated cone</a></h2>
   <p>
      The cone's local {{var_Zsca_inl}}-axis is its <dfn>main axis</dfn>, while its local {{var_Xsca_inl}}- and {{var_Ysca_inl}}-axes are its <dfn>cross axes</dfn>. The above relationship establishes the distance that any point on the cone's surface must have along the cross axes, given the point's distance from the base along the main axis.
   </p>
   <p>
      Let's define some variables real quick:
   </p>
   <lu-math>
      <m-givens>
         <dl>
            <dt>{{var_Ct}}</dt>
            <m-sep> = </m-sep>
               <dd>top vertex of the cone</dd>
            <dt>{{var_Cb}}</dt>
            <m-sep> = </m-sep>
               <dd>centerpoint of the cone's base</dd>
            <dt>{{var_Cs}}</dt>
            <m-sep> = </m-sep>
               <dd>"spine" of the cone: a vector from the tip to the base, equal to {{var_Ct}} - {{var_Cb}}</dd>
            <dt>{{var_Ca}}</dt>
            <m-sep> = </m-sep>
               <dd>axis of the cone: normalized spine</dd>
            <dt>{{var_Hp}}</dt>
            <m-sep> = </m-sep>
               <dd>hit position: a point that we presume is on the cone's curved surface</dd>
            <dt>{{var_Hs}}</dt>
            <m-sep> = </m-sep>
               <dd>hit spine position: the hit position projected onto {{var_Cs}}; this position = (({{var_Hp}} - {{var_Cb}}) &bullet; {{var_Ca}}){{var_Ca}} + {{var_Cb}}</dd>
            <dt>{{var_Ho}}</dt>
            <m-sep> = </m-sep>
               <dd>the height offset from our cone equations; this is the distance from {{var_Hs}} to {{var_Cb}} i.e. {{lu_math_vec_start}}{{var_Hs}} - {{var_Cb}}{{lu_math_vec_end}}.</dd>
            </dl>
      </m-givens>
   </lu-math>
   <p>
      {{var_Hs_inl}} is what we get when we project the hit position {{var_Hp_inl}} onto the cone's axis &mdash; its "spine." In other words, we have flattened the cone from 3D into 2D, and are looking at it from the spine: this is the circle graph from above. {{var_Hs_inl}} is the nearest point on the cone's "spine" to {{var_Hp_inl}}, so the distance between the two points is the distance from the hit position to the "spine" as a whole, and therefore also the 2D distance from the hit position to the circle's (cone's) center.
   </p>
   <p>
      We can use two equations to check whether the hit position is on the outer edge of the cone's base. The first equation is a check between the distance and the radius; recall Equations 3 and 4. The second equation constrains this check to 2D, by requiring that there be no distance between the projected hit position and the plane we've projected it onto (otherwise it would be a point/sphere test).
   </p>
   <lu-math>
      <m-row>
         {{lu_math_vec_start}}{{var_Hp}} - {{var_Hs}}{{lu_math_vec_end}}
         =
         {{var_Cr}}
      </m-row>
      <m-row>
         {{lu_math_vec_start}}{{var_Hp}} - {{var_Cb}}{{lu_math_vec_end}} = 0
      </m-row>
   </lu-math>
   <p>
      Meanwhile the distance from {{var_Hs_inl}} to the center of the cone's base, {{var_Cb_inl}}, is the height offset: the radius, the distance, that we want to check will be proportional to this. Recall Equation 2, which established the exact relationship between the height offset and radius; we can substitute this into our equation to go from 2D to 3D:
   </p>
   <lu-math>
      {{lu_math_vec_start}}{{var_Hp}} - {{var_Hs}}{{lu_math_vec_end}}
      =
      <m-raw>(</m-raw><!--
   --><m-fraction>
         <m-raw>(</m-raw>
         <m-numer>{{var_Ch}} - {{var_Ho}}</m-numer>
         <m-raw>) &divide; </m-raw>
         <m-denom>{{var_Ch}}</m-denom>
      </m-fraction><!--
   --><m-raw>)</m-raw>
      {{var_Cr}}
   </lu-math>
   <p>
      We can double-check this with some simple mental tests.
   </p>
   <ul>
      <li>
         If our hit position is at the bottom of the cone, then {{var_Ho_inl}} is zero. The righthand side resolves to a division of the cylinder's height by itself, yielding 1, which is multiplied by the cylinder's radius. Ultimately, this resolves out to a 2D radius check, as expected.
      </li>
      <li>
         If our hit position is at the top of the cone, then <lu-math data-inline>{{var_Ho}} = {{var_Ch}}</lu-math>. The righthand side's numerator comes out to zero, so the radius at the top of the cone is zero: a single point. This, too, is as expected.
      </li>
      <li>
         If our hit position is halfway along the cone's height, then the numerator on the righthand side computes to half of the cone's height. Dividing that by the cylinder's height gives us 0.5, so we end up comparing to half of the cone's radius at its base, as expected.
      </li>
   </ul>
   <p>
      Putting content on the righthand side in terms of vectors (except for the height, because leaving that as-is will make things easier later on):
   </p>
   <lu-math>
      {{lu_math_vec_start}}{{var_Hp}} - {{var_Hs}}{{lu_math_vec_end}}
      =
      <m-raw>(</m-raw><!--
   --><m-fraction>
         <m-numer>{{lu_math_vec_start}}{{var_Ct}} - {{var_Hs}}{{lu_math_vec_end}}</m-numer>
         <m-raw> &divide; </m-raw>
         <m-denom>{{var_Ch}}</m-denom>
      </m-fraction><!--
   --><m-raw>)</m-raw>
      {{var_Cr}}
   </lu-math>
   <p>
      Next, we'll divide both sides by <lu-math data-inline>{{lu_math_vec_start}}{{var_Ct}} - {{var_Hs}}{{lu_math_vec_end}}</lu-math> so that {{var_Cr_inl}} is the lone numerator on the right. (Mathematical notation sort of obscures this fact, visually, but on the righthand side, because {{var_Cr_inl}} is multiplied by the entire fraction, it is effectively part of the righthand-side numerator. We can divide by the <em>rest</em> of the righthand-side numerator to get the radius on its own.)
   </p>
   <lu-math>
      {{- lu_math_raw_endcap -}}
      <m-fraction>
         <m-numer>{{lu_math_vec_start}}{{var_Hp}} - {{var_Hs}}{{lu_math_vec_end}}</m-numer>
         <m-raw> &divide; </m-raw>
         <m-denom>{{lu_math_vec_start}}{{var_Ct}} - {{var_Hs}}{{lu_math_vec_end}}</m-denom>
      </m-fraction>
      =
      {% include lu-math/fraction.html
         numer=var_Cr
         denom=var_Ch
      %}
      {{- lu_math_raw_endcap -}}
   </lu-math>
   <p>
      Let's split up that lefthand-side fraction.
   </p>
   <lu-math>
      {{lu_math_vec_start}}{{var_Hp}} - {{var_Hs}}{{lu_math_vec_end}}
      =
      {% include lu-math/fraction.html
         numer=var_Cr
         denom=var_Ch
      %}{{lu_math_vec_start}}{{var_Ct}} - {{var_Hs}}{{lu_math_vec_end}}
   </lu-math>
   <p>
      This will be a little easier if we separate the cone's height-to-radius ratio out into a different variable, and if we square our equations. Let's do both at the same time:
   </p>
   <lu-math>
      <m-givens>
         <label>Given:</label>
         <dl>
            <dt>{{var_Cq}}</dt>
            <m-sep> = </m-sep>
               <dd>cone ratio squared</dd>
            </dl>
      </m-givens>
      <m-row>
         {{var_Cq}}
         =
         <m-fraction>
            <m-numer>{{var_Cr}}{{lu_math_sq}}</m-numer>
            <m-raw> &divide; </m-raw>
            <m-denom>{{var_Ch}}{{lu_math_sq}}</m-denom>
         </m-fraction><!--
      -->{{- lu_math_raw_endcap -}}
      </m-row>
      <m-row>
         {{lu_math_eq_numbers[5]}}
         
         {{lu_math_vec_start}}{{var_Hp}} - {{var_Hs}}{{lu_math_vec_end}}{{lu_math_sq}}
         =
         {{var_Cq}}
         &times;
         {{lu_math_vec_start}}{{var_Ct}} - {{var_Hs}}{{lu_math_vec_end}}{{lu_math_sq}}
      </m-row>
   </lu-math>
   <p>
      I think our new Equation 5 would, technically, be enough to generate a ray/cone intersection solution. However, it's a bit messy: the lefthand side uses two points, one of which is the point we want to solve for (a raycast hit position) and the other of which is itself defined in terms of the point we want to solve for. We should try to fix that &mdash; make it so that one side of the equation contains only one unknown point (the hit position), possibly alongside other known points (i.e. points that "belong to" the cone).
   </p>
   <p>
      Right now, the equation works in terms of three points in space: {{var_Hp_inl}}, {{var_Hs_inl}}, and {{var_Ct_inl}}. These points form a triangle, and our equation describes the lengths of two edges: {{var_Hp_inl}} to {{var_Hs_inl}}, and {{var_Ct_inl}} to {{var_Hs_inl}}. We therefore need to find some property that is inherent to all triangles, that we can use to rearrange our equation; we need one side of the equation to be the {{var_Hp_inl}} to {{var_Ct_inl}} edge.
   </p>
   <p>
      Let's break out the handy-dandy Pythagorean theorem, then, which describes the relationship between the lengths of a triangle's edges:
   </p>
   <lu-math>
      {{var_Asca}}{{lu_math_sq}} + 
      {{var_Bsca}}{{lu_math_sq}} = 
      {{var_Csca}}{{lu_math_sq}}
   </lu-math>
   <p>
      And therefore:
   </p>
   <lu-math>
      {{var_Csca}}{{lu_math_sq}} - 
      {{var_Bsca}}{{lu_math_sq}} = 
      {{var_Asca}}{{lu_math_sq}}
   </lu-math>
   <p>
      We can redefine <lu-math data-inline>{{lu_math_vec_start}}{{var_Hp}} - {{var_Hs}}{{lu_math_vec_end}}{{lu_math_sq}}</lu-math>, which takes the role of <lu-math data-inline>{{var_Csca}}{{lu_math_sq}}</lu-math> in the Pythagorean theorem:
   </p>
   <lu-math>
      {{lu_math_vec_start}}{{var_Hp}} - {{var_Hs}}{{lu_math_vec_end}}{{lu_math_sq}}
      =
      {{lu_math_vec_start}}{{var_Hp}} - {{var_Ct}}{{lu_math_vec_end}}{{lu_math_sq}}
      -
      {{lu_math_vec_start}}{{var_Ct}} - {{var_Hs}}{{lu_math_vec_end}}{{lu_math_sq}}
   </lu-math>
   <p>
      Let's substitute this whole formula in, replacing
      <lu-math data-inline>{{lu_math_vec_start}}{{var_Hp}} to {{var_Hs}}{{lu_math_vec_end}}{{lu_math_sq}}</lu-math>:
   </p>
   <lu-math>
      {{lu_math_vec_start}}{{var_Hp}} - {{var_Ct}}{{lu_math_vec_end}}{{lu_math_sq}}
      -
      {{lu_math_vec_start}}{{var_Ct}} - {{var_Hs}}{{lu_math_vec_end}}{{lu_math_sq}}
      =
      {{var_Cq}}
      &times;
      {{lu_math_vec_start}}{{var_Ct}} - {{var_Hs}}{{lu_math_vec_end}}{{lu_math_sq}}
   </lu-math>
   <p>
      We can add <lu-math data-inline>{{lu_math_vec_start}}{{var_Hp}} to {{var_Hs}}{{lu_math_vec_end}}{{lu_math_sq}}</lu-math> to both sides, to reduce the lefthand side down to just one length:
   </p>
   <lu-math>
      <m-row>
         {{lu_math_vec_start}}{{var_Hp}} - {{var_Ct}}{{lu_math_vec_end}}{{lu_math_sq}}
         =
         {{var_Cq}}
         &times;
         {{lu_math_vec_start}}{{var_Ct}} - {{var_Hs}}{{lu_math_vec_end}}{{lu_math_sq}}
         + 
         {{lu_math_vec_start}}{{var_Ct}} - {{var_Hs}}{{lu_math_vec_end}}{{lu_math_sq}}
      </m-row>
      <m-row>
         {{lu_math_eq_numbers[6]}}
         
         {{lu_math_vec_start}}{{var_Hp}} - {{var_Ct}}{{lu_math_vec_end}}{{lu_math_sq}}
         =
         ({{var_Cq}} + 1)
         &times;
         {{lu_math_vec_start}}{{var_Ct}} - {{var_Hs}}{{lu_math_vec_end}}{{lu_math_sq}}
      </m-row>
   </lu-math>
   <p>
      This equation will lead to a cleaner solution. If we substitute the equation for a ray in place of {{var_Hp_inl}}, the ray hit position, then we can solve for {{var_Hp_inl}} to compute that hit position given any ray. However, there's still more cleanup we can do. Let's also try to replace {{var_Hs_inl}} with something in terms of {{var_Hp_inl}}. Recall that {{var_Hs_inl}} is the projection of {{var_Hp_inl}} onto the axis {{var_Ca_inl}}.
   </p>
   <lu-math>
      <m-row>
         {{lu_math_vec_start}}{{var_Ct}} - {{var_Hs}}{{lu_math_vec_end}}{{lu_math_sq}}
         =
         {{lu_math_vec_start}}{{var_Ct}} - ({{var_Hp}} &bullet; {{var_Ca}}){{var_Ca}}{{lu_math_vec_end}}{{lu_math_sq}}
      </m-row>
      <m-row>
         {{lu_math_vec_start}}{{var_Ct}} - {{var_Hs}}{{lu_math_vec_end}}
         =
         {{lu_math_vec_start}}{{var_Ct}} - ({{var_Hp}} &bullet; {{var_Ca}}){{var_Ca}}{{lu_math_vec_end}}
      </m-row>
   </lu-math>
   <p>
      Remember that {{var_Hs_inl}} is the hit position projected onto the cylinder's "spine." To compute that, we start with <lu-math data-inline>{{var_Hp}} - {{var_Cb}}</lu-math>, to get the hit position relative to the cylinder's base. We then project <em>that</em> onto the cylinder's axis vector:
   </p>
   <lu-math>
      (({{var_Hp}} - {{var_Cb}}) &bullet; {{var_Ca}}) &times; {{var_Ca}}
   </lu-math>
   <p>
      And then finally, we add the cylinder's base position back in, to move us back to world-relative coordinates:
   </p>
   <lu-math>
      {{var_Hs}}
      = 
      {{var_Cb}} + (({{var_Hp}} - {{var_Cb}}) &bullet; {{var_Ca}}) &times; {{var_Ca}}
   </lu-math>
   <p>
      With that in mind, let's see if we can simplify the righthand side of Equation 6. Let's start by expanding {{var_Hs_inl}}:
   </p>
   <lu-math>
      <m-row>
         {{lu_math_vec_start}}{{var_Ct}} - {{var_Hs}}{{lu_math_vec_end}}{{lu_math_sq}}
         =
         {{lu_math_vec_start}}{{var_Ct}} - <mark>({{var_Cb}} + (({{var_Hp}} - {{var_Cb}}) &bullet; {{var_Ca}}){{var_Ca}})</mark>{{lu_math_vec_end}}{{lu_math_sq}}
      </m-row>
   </lu-math>
   <p>
      Now, if we think about it, the cylinder's tip is really just the cylinder's base, plus the cylinder's height times the cylinder's axis:
   </p>
   <lu-math>
      <m-row>
         {{lu_math_vec_start}}{{var_Ct}} - {{var_Hs}}{{lu_math_vec_end}}{{lu_math_sq}}
         =
         {{lu_math_vec_start}}<mark>({{var_Cb}} + {{var_Ca}}{{var_Ch}})</mark> - ({{var_Cb}} + (({{var_Hp}} - {{var_Cb}}) &bullet; {{var_Ca}}){{var_Ca}}){{lu_math_vec_end}}{{lu_math_sq}}
      </m-row>
   </lu-math>
   <p>
      Within the righthand side, we can strip out the additions of the base on both sides. (The righthand side is taking the distance between two points; removing those additions means translating both points by the same vector, which has no effect on the distance between them and therefore is a valid way to simplify the equation.)
   </p>
   <lu-math>
      <m-row>
         {{lu_math_vec_start}}{{var_Ct}} - {{var_Hs}}{{lu_math_vec_end}}{{lu_math_sq}}
         =
         {{lu_math_vec_start}}({{var_Ca}}{{var_Ch}}) - (({{var_Hp}} - {{var_Cb}}) &bullet; {{var_Ca}}){{var_Ca}}{{lu_math_vec_end}}{{lu_math_sq}}
      </m-row>
   </lu-math>
   <p>
      We can also drop the multiplications by {{var_Ca_inl}}. Those multiplications were of lengths by an axis vector, to scale along that axis; dropping the multiplications means that we're working with raw lengths, so we go from a <lu-math data-inline>{{lu_math_vec_start}}length operator{{lu_math_vec_end}}</lu-math> to parentheses:
   </p>
   <lu-math>
      <m-row>
         {{lu_math_vec_start}}{{var_Ct}} - {{var_Hs}}{{lu_math_vec_end}}{{lu_math_sq}}
         =
         ({{var_Ch}} - ({{var_Hp}} - {{var_Cb}}) &bullet; {{var_Ca}}){{lu_math_sq}}
      </m-row>
   </lu-math>
   <p>
      Finally, we can flip the righthand side: instead of measuring the projected distance from {{var_Hp_inl}} to the bottom of the cylinder and then subtracting that from the cylinder's height, we can instead measure the projected distance from {{var_Hp_inl}} to the top of the cylinder.
   </p>
   <lu-math>
      <m-row>
         {{lu_math_vec_start}}{{var_Ct}} - {{var_Hs}}{{lu_math_vec_end}}{{lu_math_sq}}
         =
         (<mark>({{var_Hp}} - {{var_Ct}})</mark> &bullet; {{var_Ca}}){{lu_math_sq}}
      </m-row>
   </lu-math>
   <p>
      Our final cone equation, substituting out <lu-math data-inline>{{lu_math_vec_start}}{{var_Ct}} - {{var_Hs}}{{lu_math_vec_end}}{{lu_math_sq}}</lu-math> from Equation 6, is as follows:
   </p>
   <lu-math>
      <m-row>
         {{lu_math_eq_numbers[7]}}
         
         {{lu_math_vec_start}}{{var_Hp}} - {{var_Ct}}{{lu_math_vec_end}}{{lu_math_sq}}
         =
         ({{var_Cq}} + 1)
         &times;
         <mark>(({{var_Hp}} - {{var_Ct}}) &bullet; {{var_Ca}}){{lu_math_sq}}</mark>
      </m-row>
   </lu-math>
   <p>
      Keep in mind that this equation only includes the variable for the cone's tip, not the cone's base. We have effectively removed most of our vectors from the equation, and so just like with the parametric equations, this implicit equation tests whether a point lies on the curved outer surface of an infinitely tall cone anchored at its tip. That's fine, though. Testing a finite cone just involves a distance check between the point and the tip; and testing against the cone's flat endcap involves a point/disc intersection check. Our equation here tests the "unique" part of the cone.
   </p>
</section>

<section>
   <h2><a name="solving">Solving for the ray</a></h2>
   <p>
      A ray is commonly defined in terms of a starting point, or <dfn>origin</dfn>, and a normalized direction vector. We can therefore define the hit position in terms of the same.
   </p>
   <lu-math>
      <m-givens>
         <label>Given:</label>
         <dl>
            <dt>{{var_Ro}}</dt>
            <m-sep> = </m-sep>
               <dd>the ray's origin</dd>
            <dt>{{var_Rd}}</dt>
            <m-sep> = </m-sep>
               <dd>the ray's direction</dd>
            <dt>{{var_Hp}}</dt>
            <m-sep> = </m-sep>
               <dd>the position at which the ray hits some surface</dd>
            <dt>{{var_Hd}}</dt>
            <m-sep> = </m-sep>
               <dd>the hit distance: the distance from the ray origin to the hit position</dd>
            </dl>
      </m-givens>
      <m-row>
         {{var_Hp}}
         =
         {{var_Ro}} + {{var_Rd}}{{var_Hd}}
      </m-row>
   </lu-math>
   <p>
      We can substitute this equation into our cone equation above, and then attempt to solve for the hit distance {{var_Hd_inl}}:
   </p>
   <lu-math>
      <m-row>
         {{lu_math_vec_start}}<mark>{{var_Ro}} + {{var_Rd}}{{var_Hd}}</mark> - {{var_Ct}}{{lu_math_vec_end}}{{lu_math_sq}}
          = 
         ({{var_Cq}} + 1)
         &times;
         ((<mark>{{var_Ro}} + {{var_Rd}}{{var_Hd}}</mark> - {{var_Ct}}) &bullet; {{var_Ca}}){{lu_math_sq}}
      </m-row>
   </lu-math>
   <p>
      On both sides of the equation, we subtract {{var_Ct_inl}} from {{var_Ro_inl}}. Let's simplify the equation a bit by defining that difference as a vector:
   </p>
   <lu-math>
      <m-givens>
         <label>Given:</label>
         <dl>
            <dt>{{var_Rl}}</dt>
            <m-sep> = </m-sep>
               <dd>the ray's cone-tip-relative origin = {{var_Ro}} - {{var_Ct}}</dd>
            </dl>
      </m-givens>
      <m-row>
         {{lu_math_vec_start}}{{var_Rl}} + {{var_Rd}}{{var_Hd}}{{lu_math_vec_end}}{{lu_math_sq}}
         =
         ({{var_Cq}} + 1)
         &times;
         (({{var_Rl}} + {{var_Rd}}{{var_Hd}}) &bullet; {{var_Ca}}){{lu_math_sq}}
      </m-row>
   </lu-math>
   <p>
      The squared length of a vector is equal to the dot product of the vector with itself; we can use that to expand the lefthand side:
   </p>
   <lu-math>
      <m-row>
         ({{var_Rl}} + {{var_Rd}}{{var_Hd}}) &bullet; 
         ({{var_Rl}} + {{var_Rd}}{{var_Hd}})
         =
         ({{var_Cq}} + 1)
         &times;
         (({{var_Rl}} + {{var_Rd}}{{var_Hd}}) &bullet; {{var_Ca}}){{lu_math_sq}}
      </m-row>
   </lu-math>
   <p>
      We can also expand the righthand side if we keep in mind that dot products obey <abbr title="First, inside; outside last">FOIL</abbr>. The squared parentheses on the righthand side only use three terms, nor four, but we can just add a zero term and then use FOIL.
   </p>
   <lu-math>
      <m-givens>
         <label>Given:</label>
         <dl>
            <dt>{{var_Vz}}</dt>
            <m-sep> = </m-sep>
               <dd>the vector (0, 0, 0)</dd>
            </dl>
      </m-givens>
      <m-solvestep>
         <m-content>
            ({{var_Rl}} + {{var_Rd}}{{var_Hd}}) &bullet; {{var_Ca}}
            =
            ({{var_Rl}} + {{var_Rd}}{{var_Hd}}) &bullet; ({{var_Ca}} + {{var_Vz}})
         </m-content>
      </m-solvestep>
      <m-solvestep>
         <m-content>
            ({{var_Rl}} + {{var_Rd}}{{var_Hd}}) &bullet; ({{var_Ca}} + {{var_Vz}})
            =
            {{var_Rl}} &bullet; {{var_Ca}} + {{var_Rl}} &bullet; {{var_Vz}} + {{var_Rd}}{{var_Hd}} &bullet; {{var_Ca}} + {{var_Rd}}{{var_Hd}} &bullet; {{var_Vz}}
         </m-content>
      </m-solvestep>
      <m-solvestep>
         <m-content>
            ({{var_Rl}} + {{var_Rd}}{{var_Hd}}) &bullet; ({{var_Ca}} + {{var_Vz}})
            =
            {{var_Rl}} &bullet; {{var_Ca}} + {{var_Rd}}{{var_Hd}} &bullet; {{var_Ca}}
         </m-content>
      </m-solvestep>
   </lu-math>
   <p>
      So the ray-and-cone equation, with the righthand side expanded, is:
   </p>
   <lu-math>
      <m-solvestep>
         <m-content>
            ({{var_Rl}} + {{var_Rd}}{{var_Hd}}) &bullet; 
            ({{var_Rl}} + {{var_Rd}}{{var_Hd}})
            =
            ({{var_Cq}} + 1)
            &times;
            ({{var_Rl}} &bullet; {{var_Ca}} + {{var_Rd}}{{var_Hd}} &bullet; {{var_Ca}}){{lu_math_sq}}
         </m-content>
      </m-solvestep>
   </lu-math>
   <p>
      We can expand the dot product on the lefthand side using FOIL as well:
   </p>
   <lu-math>
      <m-solvestep>
         <m-content>
            {{var_Rl}} &bullet; </var>{{var_Rl}} + {{var_Rl}} &bullet; {{var_Rd}}{{var_Hd}} + {{var_Rd}}{{var_Hd}} &bullet; {{var_Rl}} + {{var_Rd}}{{var_Hd}} &bullet; {{var_Rd}}{{var_Hd}}
            =
            ({{var_Cq}} + 1)
            &times;
            ({{var_Rl}} &bullet; {{var_Ca}} + {{var_Rd}}{{var_Hd}} &bullet; {{var_Ca}}){{lu_math_sq}}
         </m-content>
      </m-solvestep>
      <m-solvestep>
         <m-content>
            ({{var_Rl}} &bullet; {{var_Rl}}) + 
            2({{var_Rl}} &bullet; {{var_Rd}}{{var_Hd}}) + 
            ({{var_Rd}}{{var_Hd}}) &bullet; ({{var_Rd}}{{var_Hd}})
            =
            ({{var_Cq}} + 1)
            &times;
            ({{var_Rl}} &bullet; {{var_Ca}} + {{var_Rd}}{{var_Hd}} &bullet; {{var_Ca}}){{lu_math_sq}}
         </m-content>
      </m-solvestep>
   </lu-math>
   <p>
      We can expand the squaring on the righthand side as well:
   </p>
   <lu-math>
      <m-solvestep>
         <m-content>
            ({{var_Asca}} + {{var_Bsca}}){{lu_math_sq}} 
            = 
            {{var_Asca}}{{lu_math_sq}} + 2{{var_Asca}}{{var_Bsca}} + {{var_Bsca}}{{lu_math_sq}}
         </m-content>
      </m-solvestep>
      <m-solvestep>
         <m-content>
            ({{var_Rl}} &bullet; {{var_Rl}}) + 
            2({{var_Rl}} &bullet; {{var_Rd}}{{var_Hd}}) + 
            ({{var_Rd}}{{var_Hd}}) &bullet; ({{var_Rd}}{{var_Hd}})
            =
            ({{var_Cq}} + 1) 
            &times; 
            (({{var_Rl}} &bullet; {{var_Ca}}){{lu_math_sq}} + 2({{var_Rl}} &bullet; {{var_Ca}})({{var_Rd}}{{var_Hd}} &bullet; {{var_Ca}}) + ({{var_Rd}}{{var_Hd}} &bullet; {{var_Ca}}){{lu_math_sq}})
         </m-content>
      </m-solvestep>
   </lu-math>
   <p>
      And finally: for any vector {{var_Vvec_inl}} and scalar {{var_Ssca_inl}}:
   </p>
   <lu-math>
      <m-row>
         ({{var_Ssca}}{{var_Vvec}}) &bullet; ({{var_Ssca}}{{var_Vvec}}) = ({{var_Vvec}} &bullet; {{var_Vvec}}){{var_Ssca}}{{lu_math_sq}}
      </m-row>
      {{lu_math_therefore_block}}
      <m-solvestep>
         <m-content>
            ({{var_Rl}} &bullet; {{var_Rl}}) + 
            2({{var_Rl}} &bullet; {{var_Rd}}{{var_Hd}}) + 
            ({{var_Rd}} &bullet; {{var_Rd}})<mark>{{var_Hd}}{{lu_math_sq}}</mark>
            =
            ({{var_Cq}} + 1) 
            &times; 
            (({{var_Rl}} &bullet; {{var_Ca}}){{lu_math_sq}} + 2({{var_Rl}} &bullet; {{var_Ca}})({{var_Rd}}{{var_Hd}} &bullet; {{var_Ca}}) + ({{var_Rd}}{{var_Hd}} &bullet; {{var_Ca}}){{lu_math_sq}})
         </m-content>
      </m-solvestep>
   </lu-math>
   <p>
      Now, let's group them based on {{var_Hd_inl}}. We'll start by subtracting one side of the equation from the other:
   </p>
   <lu-math>
      <m-solvestep>
         <m-content>
            ({{var_Rl}} &bullet; {{var_Rl}}) + 
            2({{var_Rl}} &bullet; {{var_Rd}}{{var_Hd}}) + 
            ({{var_Rd}} &bullet; {{var_Rd}}){{var_Hd}}{{lu_math_sq}}<!--
         --><mark> - 
            ({{var_Cq}} + 1) 
            &times; 
            (({{var_Rl}} &bullet; {{var_Ca}}){{lu_math_sq}} + 2({{var_Rl}} &bullet; {{var_Ca}})({{var_Rd}}{{var_Hd}} &bullet; {{var_Ca}}) + ({{var_Rd}}{{var_Hd}} &bullet; {{var_Ca}}){{lu_math_sq}}) 
            = 0</mark>
         </m-content>
      </m-solvestep>
   </lu-math>
   <p>
      Next, we'll unpack the multiplication by <lu-math data-inline>(<var>C<sub>q</sub> + 1)</lu-math>, and then merge the groups that are both multiplied by 2:
   </p>
   <lu-math>
      <m-solvestep>
         <m-content>
            ({{var_Rl}} &bullet; {{var_Rl}}) + 
            2({{var_Rl}} &bullet; {{var_Rd}}{{var_Hd}}) + 
            ({{var_Rd}} &bullet; {{var_Rd}}){{var_Hd}}{{lu_math_sq}} 
            - 
            <mark>({{var_Cq}} + 1)</mark>({{var_Rl}} &bullet; {{var_Ca}}){{lu_math_sq}} - 
            2<mark>({{var_Cq}} + 1)</mark>({{var_Rl}} &bullet; {{var_Ca}})({{var_Rd}}{{var_Hd}} &bullet; {{var_Ca}}) - 
            <mark>({{var_Cq}} + 1)</mark>({{var_Rd}}{{var_Hd}} &bullet; {{var_Ca}}){{lu_math_sq}}
            = 0
         </m-content>
      </m-solvestep>
      <m-solvestep>
         <m-content>
            ({{var_Rl}} &bullet; {{var_Rl}}) + 
            2<mark>(</mark>({{var_Rl}} &bullet; {{var_Rd}}{{var_Hd}})<mark> - ({{var_Cq}} + 1)({{var_Rl}} &bullet; {{var_Ca}})({{var_Rd}}{{var_Hd}} &bullet; {{var_Ca}}))</mark> + 
            ({{var_Rd}} &bullet; {{var_Rd}}){{var_Hd}}{{lu_math_sq}}
            - 
            ({{var_Cq}} + 1)({{var_Rl}} &bullet; {{var_Ca}}){{lu_math_sq}} - 
            ({{var_Cq}} + 1)({{var_Rd}}{{var_Hd}} &bullet; {{var_Ca}}){{lu_math_sq}}
            = 0
         </m-content>
      </m-solvestep>
   </lu-math>
   <p>
      Next, we want to move {{var_Hd_inl}} outside of some of the dot products. Multiplying a vector by a scalar is the same as taking the dot product of that vector with another vector whose terms are all that same scalar; and the dot product between two vectors is <dfn>commutative</dfn>: you can swap the lefthand and righthand sides around and get the same result; therefore, for any two vectors <lu-math data-inline><var>A</var></lu-math> and <lu-math data-inline><var>B</var></lu-math>, and a scalar {{var_Csca_inl}},
   </p>
   <lu-math>
      <m-row>
         {{var_Csca}}<var>A</var> &bullet; <var>B</var> = (<var>A</var> &bullet; <var>B</var>){{var_Csca}}
      </m-row>
      <m-row>
         ({{var_Bsca}}<m-raw data-screen-reader-only> &times; </m-raw><var>A</var> &bullet; <var>B</var>){{lu_math_sq}} = (<var>A</var> &bullet; <var>B</var>){{lu_math_sq}}<m-raw> &times; </m-raw>{{var_Bsca}}{{lu_math_sq}}
      </m-row>
      {{lu_math_therefore_block}}
      <m-solvestep>
         <m-content>
            ({{var_Rl}} &bullet; {{var_Rl}}) + 
            2(({{var_Rl}} &bullet; {{var_Rd}})<mark>{{var_Hd}}</mark> - ({{var_Cq}} + 1)({{var_Rl}} &bullet; {{var_Ca}})({{var_Rd}} &bullet; {{var_Ca}})<mark>{{var_Hd}}</mark>) + 
            ({{var_Rd}} &bullet; {{var_Rd}}){{var_Hd}}{{lu_math_sq}}
            - 
            ({{var_Cq}} + 1)({{var_Rl}} &bullet; {{var_Ca}}){{lu_math_sq}} - 
            ({{var_Cq}} + 1)({{var_Rd}} &bullet; {{var_Ca}}){{lu_math_sq}}<mark>{{var_Hd}}{{lu_math_sq}}</mark>
            = 0
         </m-content>
      </m-solvestep>
      <m-solvestep>
         {{lu_math_expl_start}}
            We're just rearranging terms in this row, and not making any real changes.
         {{lu_math_expl_end}}
         <m-content>
            ({{var_Rd}} &bullet; {{var_Rd}}){{var_Hd}}{{lu_math_sq}} - 
            ({{var_Cq}} + 1)({{var_Rd}} &bullet; {{var_Ca}}){{lu_math_sq}}{{var_Hd}}{{lu_math_sq}}  + 
            2(({{var_Rl}} &bullet; {{var_Rd}}){{var_Hd}} - ({{var_Cq}} + 1)({{var_Rl}} &bullet; {{var_Ca}})({{var_Rd}} &bullet; {{var_Ca}}){{var_Hd}})
            - 
            ({{var_Cq}} + 1)({{var_Rl}} &bullet; {{var_Ca}}){{lu_math_sq}} + 
            ({{var_Rl}} &bullet; {{var_Rl}})
            = 0
         </m-content>
      </m-solvestep>
      <m-solvestep>
         {{lu_math_expl_start}}
            Grouped a few terms by <lu-math data-inline>{{var_Hd}}{{lu_math_sq}}</lu-math>.
         {{lu_math_expl_end}}
         <m-content>
            <mark>(({{var_Rd}} &bullet; {{var_Rd}}) - ({{var_Cq}} + 1)({{var_Rd}} &bullet; {{var_Ca}}){{lu_math_sq}})</mark>{{var_Hd}}{{lu_math_sq}}</mark> + 
            2(({{var_Rl}} &bullet; {{var_Rd}}){{var_Hd}} - ({{var_Cq}} + 1)({{var_Rl}} &bullet; {{var_Ca}})({{var_Rd}} &bullet; {{var_Ca}}){{var_Hd}})
            - 
            ({{var_Cq}} + 1)({{var_Rl}} &bullet; {{var_Ca}}){{lu_math_sq}} + 
            ({{var_Rl}} &bullet; {{var_Rl}})
            = 0
         </m-content>
      </m-solvestep>
      <m-solvestep>
         <m-content>
            (({{var_Rd}} &bullet; {{var_Rd}}) - ({{var_Cq}} + 1)({{var_Rd}} &bullet; {{var_Ca}}){{lu_math_sq}}){{var_Hd}}{{lu_math_sq}}</mark> + 
            2(({{var_Rl}} &bullet; {{var_Rd}}) - ({{var_Cq}} + 1)({{var_Rl}} &bullet; {{var_Ca}})({{var_Rd}} &bullet; {{var_Ca}}))<mark>{{var_Hd}}</mark>
            - 
            ({{var_Cq}} + 1)({{var_Rl}} &bullet; {{var_Ca}}){{lu_math_sq}} + 
            ({{var_Rl}} &bullet; {{var_Rl}})
            = 0
         </m-content>
      </m-solvestep>
      <m-solvestep>
         {{lu_math_expl_start}}
            We're just rearranging terms in this row, and not making any real changes.
         {{lu_math_expl_end}}
         <m-content>
            (({{var_Rd}} &bullet; {{var_Rd}}) - ({{var_Cq}} + 1)({{var_Rd}} &bullet; {{var_Ca}}){{lu_math_sq}}){{var_Hd}}{{lu_math_sq}} + 
            2(({{var_Rl}} &bullet; {{var_Rd}}) - ({{var_Cq}} + 1)({{var_Rl}} &bullet; {{var_Ca}})({{var_Rd}} &bullet; {{var_Ca}})){{var_Hd}}<!--
         --><mark> + 
            ({{var_Rl}} &bullet; {{var_Rl}})
             - 
            ({{var_Cq}} + 1)({{var_Rl}} &bullet; {{var_Ca}}){{lu_math_sq}}</mark>
            = 0
         </m-content>
      </m-solvestep>
   </lu-math>
   <p>
      <span class="different-wording-for-the-blind">
         <span class="sighted" aria-hidden="true">This is a quadratic equation. Can you see it?</span>
         <span class="blind">This is a quadratic equation. Here &mdash; I'll mark the different parts in different colors and show you.</span>
      </span>
   </p>
   <lu-math>
      <m-row class="announce-marks">
         <mark class="mark-1">{{var_Asca}}</mark><var>x</var>{{lu_math_sq}} + <mark class="mark-2">{{var_Bsca}}</mark><var>x</var> + <mark class="mark-3">{{var_Csca}}</mark>
      </m-row>
   </lu-math>
   <p>
      If {{var_Hd_inl}} is the "{{var_Xsca_inl}}" in our quadratic equation, then...
   </p>
   <lu-math>
      <m-row class="announce-marks">
         <mark class="mark-1">(({{var_Rd}} &bullet; {{var_Rd}}) - ({{var_Cq}} + 1)({{var_Rd}} &bullet; {{var_Ca}}){{lu_math_sq}})</mark>{{var_Hd}}{{lu_math_sq}}
         + 
         <mark class="mark-2">2(({{var_Rl}} &bullet; {{var_Rd}}) - ({{var_Cq}} + 1)({{var_Rl}} &bullet; {{var_Ca}})({{var_Rd}} &bullet; {{var_Ca}}))</mark>{{var_Hd}}
          + 
         <mark class="mark-3">({{var_Rl}} &bullet; {{var_Rl}})
          - 
         ({{var_Cq}} + 1)({{var_Rl}} &bullet; {{var_Ca}}){{lu_math_sq}}</mark>
         = 0
      </m-row>
      <m-givens>
         <label>given:</label>
         <dl>
            <dt>{{var_Asca}}</dt>
            <m-sep> = </m-sep>
               <dd>({{var_Rd}} &bullet; {{var_Rd}}) - ({{var_Cq}} + 1)({{var_Rd}} &bullet; {{var_Ca}}){{lu_math_sq}}</dd>
            <dt>{{var_Bsca}}</dt>
            <m-sep> = </m-sep>
               <dd>2(({{var_Rl}} &bullet; {{var_Rd}}) - ({{var_Cq}} + 1)({{var_Rl}} &bullet; {{var_Ca}})({{var_Rd}} &bullet; {{var_Ca}}))</dd>
            <dt>{{var_Csca}}</dt>
            <m-sep> = </m-sep>
               <dd>({{var_Rl}} &bullet; {{var_Rl}}) - ({{var_Cq}} + 1)({{var_Rl}} &bullet; {{var_Ca}}){{lu_math_sq}}</dd>
         </dl>
      </m-givens>
   </lu-math>
   <p>
      And of course, per the quadratic formula, the quadratic equation is true whenever {{var_Hd_inl}} is defined as follows:
   </p>
   <lu-math>
      {{var_Hd}}
       = 
      {%- capture numerator -%}
         -{{var_Bsca}} &plusmn; 
         {% capture temporary -%}
            {{var_Bsca}}{{lu_math_sq}} - 4{{var_Asca}}{{var_Csca}}
         {%- endcapture -%}
         {%- include lu-math/sqrt.html content=temporary -%}
      {%- endcapture -%}
      {% capture denominator -%}
         2{{var_Asca}}
      {%- endcapture %}
      {% include lu-math/fraction.html
         numer=numerator
         denom=denominator
         
         numer_is_expr=true
         denom_is_expr=true
      -%}
      {{- lu_math_raw_endcap -}}
   </lu-math>
   <p>
      The <dfn>discrminant</dfn> can be used to check how many solutions exist &mdash; that is, whether the ray intersects the cone, and if so, how many times &mdash; and is defined as follows:
   </p>
   <lu-math>
      {{var_Bsca}}{{lu_math_sq}} - 4{{var_Asca}}{{var_Csca}}
   </lu-math>
   <p>
      If the discriminant is negative, then no solutions exist; there is no intersection. If the discriminant is positive, then there are two intersections. If the discriminant is zero, then there is only one intersection; if you compute the two intersection points (differing based on &plusmn; the square root of the discriminant), then they will be identical.
   </p>
   <p>
      Recall that for any intersection, <lu-math data-inline>{{var_Hp}} = {{var_Ro}} + {{var_Rd}}{{var_Hd}}</lu-math>. Our process above tests for an intersection against an infinite cone, so we now need to constrain it.
   </p>
   <p>
      The following expression will be true if a hit position is on the finite cone. We are taking the hit position's distance to the cone's tip, projecting that onto the cone's axis to get the hit position's cone-relative height offset, and testing that projected distance against the cone's height.
   </p>
   <lu-math>
      0 &leq; ({{var_Ct}} - {{var_Hp}}) &bullet; {{var_Ca}} &leq; {{lu_math_vec_start}}{{var_Ct}} - {{var_Cb}}{{lu_math_vec_end}}
   </lu-math>
   <p>
      The following expression will be true if the hit position is below the finite cone. In that case, you should test for a ray/disc intersection with the cone's endcap.
   </p>
   <lu-math>
      ({{var_Ct}} - {{var_Hp}}) &bullet; {{var_Ca}} &gt; {{lu_math_vec_start}}{{var_Ct}} - {{var_Cb}}{{lu_math_vec_end}}
   </lu-math>
   <p>
      The following expression will be true if the hit position is above the finite cone. In this situation, you have to ignore the hit position. Remember that odd thing I pointed out at the start: our equations don't describe just <em>one</em> cone. The cone isn't bounded on <em>either side</em>, so if you go above the tip, the cone turns inside out and begins to widen again. Essentially, the equations describe something akin to an hourglass shape; so, we have to ignore everything above the tip where the normal cone and the inside-out cone meet.
   </p>
   <lu-math>
      0 &gt; ({{var_Ct}} - {{var_Hp}}) &bullet; {{var_Ca}}
   </lu-math>
   <p>
      Lastly, we also have to ignore any hit positions that result from a negative hit distance {{var_Hd_inl}}, as these represent points behind the ray.
   </p>
   <lu-math>
      0 &leq; {{var_Hd}}
   </lu-math>
</section>

<section>
   <h2><a name="free-code">Free code!</a></h2>
   <p>
      The following C++ code is licensed under CC0 (<a href="https://creativecommons.org/publicdomain/zero/1.0/legalcode">full legal text</a> / <a href="https://creativecommons.org/publicdomain/zero/1.0/">summary</a>), and so is effectively a public domain work. You can incorporate it into your programs without the need for attribution, payment, or similar. (That said, linking back here would be polite!)
   </p>
   <p>
      This code makes use of the <a href="https://github.com/g-truc/glm">GLM</a> library for vector math. It has 
      transitive dependencies on some of my other math, in the form of <a href="{% link _articles/ray-disc-intersection.html %}"><code>ray_disc_intersection</code></a> and, through it, <a href="{% link _articles/ray-plane-intersection.html %}"><code>ray_plane_intersection</code></a>.
      </li>
   </ul>
{% highlight cpp %}
//
// Given coefficients in a quadratic equation, this function gives you the roots 
// and returns the number of roots. If there is only one root, then both root 
// variables are set to the same value.
//
int quadratic_roots(
   const float a,
   const float b,
   const float c,
   //
   float& root_lower,
   float& root_upper
) {
   constexpr auto EPSILON = 1e-8;

   float discriminant = (b * b) - (4.0 * a * c);
   if (discriminant > EPSILON) {
      float b_term = b < EPSILON ? -b + sqrt(discriminant) : -b - sqrt(discriminant);

      root_lower = b_term / (2.0 * a); // quadratic formula
      root_upper = (2.0 * c) / b_term; // citardauq formula

      if (root_lower > root_upper)
         std::swap(root_lower, root_upper); // use of both formulae, plus this, avoids catastrophic cancellation due to floating-point limits

      return 2;
   } else if (discriminant > -EPSILON && discriminant <= EPSILON) {
      root_lower = -(b / 2.0 * a);
      root_upper = root_lower;
      return 1;
   }
   root_lower = NAN;
   root_upper = NAN;
   return 0;
}
   
bool ray_cone_intersection(
   const glm::vec3& ray_origin,
   const glm::vec3& ray_direction, // must be normalized
   
   const glm::vec3& cone_tip,
   const glm::vec3& cone_base_centerpoint,
   float cone_base_radius,

   const bool hits_from_inside_count,
   
   float& out_hit_distance
) {
   //
   // First, identify intersections between a line and an infinite cone. An infinite 
   // cone has no base and extends in both directions -- downward from the tip as you 
   // would expect, but also inside-out upward from the tip.
   //
   glm::vec3 Rl = ray_origin - cone_tip;            // Ray origin local to centerpoint
   glm::vec3 Cs = cone_tip - cone_base_centerpoint; // Cone spine
   float     Ch = glm::length(Cs);                  // Cone height
   glm::vec3 Ca = Cs / Ch;                          // Cone axis
   float     Cq = (cone_base_radius * cone_base_radius) / (Ch * Ch); // Cone ratio

   auto Rd_dot_Ca = glm::dot(ray_direction, Ca);
   auto Rl_dot_Rl = glm::dot(Rl, Rl);
   auto Rl_dot_Ca = glm::dot(Rl, Ca);

   float a = glm::dot(ray_direction, ray_direction) - (Cq + 1) * (Rd_dot_Ca * Rd_dot_Ca);
   float b = 2 * (glm::dot(ray_direction, Rl) - (Cq + 1) * Rl_dot_Ca * Rd_dot_Ca);
   float c = Rl_dot_Rl - (Cq + 1) * Rl_dot_Ca * Rl_dot_Ca;

   float hit_near;
   float hit_away;
   auto  count = quadratic_roots(a, b, c, hit_near, hit_away);
   if (count == 0) {
      //
      // There is no intersection between a line (i.e. a "double-sided" ray) and the 
      // infinite cone that matches our finite cone. This means that we cannot be 
      // hitting any part of the cone: if we were hitting the base from the inside, 
      // for example, then the "back of our ray" would be hitting the upper part of 
      // the infinite cone.
      //
      return false;
   }
   //
   // Now, we need to take our intersection points and ensure that they lie on the 
   // surface of a finite cone. If one of them is below the finite cone, then we need 
   // to check for a valid intersection with the cone's base.
   //
   if (count > 2) {
      std::unreachable(); // requires C++23 or a polyfill
   }
   bool  valid1 = true;
   bool  valid2 = true;
   //
   glm::vec3 Hp1 = ray_origin + ray_direction * hit_near;
   glm::vec3 Hp2 = ray_origin + ray_direction * hit_away;
   float     Ho1 = glm::dot(cone_tip - Hp1, Ca); // height offset
   float     Ho2 = glm::dot(cone_tip - Hp2, Ca);
   //
   int valid_count = count;
   if (hit_near < 0.0 || Ho1 < 1.0e-8 || Ho1 > Ch) {
      valid1 = false;
      --valid_count;
   }
   if (hit_away < 0.0 || Ho2 < 1.0e-8 || Ho2 > Ch) {
      valid2 = false;
      if (count > 1)
         --valid_count;
   }
   //
   if (valid_count == 0) {
      if (hits_from_inside_count) {
         //
         // The ray never hits the bounded cone's curved surface. If it originates 
         // from inside the cone and points "downward," however, it could still hit 
         // the cone's endcap from inside.
         //
         if (ray_disc_intersection(ray_origin, ray_direction, cone_base_centerpoint, Ca, cone_base_radius, hit_away)) {
            out_hit_distance = hit_away;
            return true;
         }
      }
      return false;
   }
   if (valid_count == 1) {
      //
      // The ray hits the cone's curved surface only once. This can only happen under 
      // two cases: the ray originates from inside the cone, and points outward; or 
      // the ray passes through the bounded cone once and through the cone's endcap.
      //
      if (valid2) {
         Hp1 = Hp2;
         Ho1 = Ho2;
         valid1   = true;
         hit_near = hit_away;
      }
      valid2 = ray_disc_intersection(ray_origin, ray_direction, cone_base_centerpoint, Ca, cone_base_radius, hit_away);
      //
      if (!valid2) {
         if (!hits_from_inside_count) {
            //
            // The ray only hits the finite cone's curved surface once, and never hits 
            // the cone's base. This means that the ray must be originating from inside 
            // of the cone.
            //
            return false;
         }
         out_hit_distance = hit_near;
         return true;
      }
   }
   out_hit_distance = std::min(hit_near, hit_away);
   return true;
}
{% endhighlight %}
</section>