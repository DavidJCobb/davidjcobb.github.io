---
title: Ray/cylinder intersections
tags:
 - 3D
 - geometry
 - intersection
 - math
 - raycasting
social_media:
   description: The math behind doing raycasts for 3D cylinders, with the mathematical derivation fully explained step, by step. Includes public-domain code.
extra_css_files:
 - lu-math.css
table_of_contents:
 - id:    parametric
   title: Parametric surface of a cylinder
 - id:    implicit
   title: Implicit surface of a cylinder
 - id:    transformed
   title: Handling a translated and rotated cylinder
 - id:    solving
   title: Solving for the ray
 - id:    free-code
   title: Free code!
   
---
{%- include lu-math/defines.html -%}

{%- assign var_Ca     = "<var data-type='vector'>C<sub>a</sub></var>" -%}
{%- assign var_Cb     = "<var data-type='vector'>C<sub>b</sub></var>" -%}
{%- assign var_Ch     = "<var>C<sub>h</sub></var>" -%}
{%- assign var_Cr     = "<var>C<sub>r</sub></var>" -%}
{%- assign var_Cs     = "<var data-type='vector'>C<sub>s</sub></var>" -%}
{%- assign var_Ct     = "<var data-type='vector'>C<sub>t</sub></var>" -%}
{%- assign var_Hd     = "<var>H<sub>d</sub></var>" -%}
{%- assign var_Hn     = "<var data-type='vector'>H<sub>n</sub></var>" -%}
{%- assign var_Ho     = "<var>H<sub>o</sub></var>" -%}
{%- assign var_Hp     = "<var data-type='vector'>H<sub>p</sub></var>" -%}
{%- assign var_Hs     = "<var data-type='vector'>H<sub>s</sub></var>" -%}
{%- assign var_Rd     = "<var data-type='vector'>R<sub>d</sub></var>" -%}
{%- assign var_Rl     = "<var data-type='vector'>R<sub>l</sub></var>" -%}
{%- assign var_Ro     = "<var data-type='vector'>R<sub>o</sub></var>" -%}
{%- assign var_Ca_inl = var_Ca | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Cb_inl = var_Cb | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Ch_inl = var_Ch | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Cr_inl = var_Cr | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Cs_inl = var_Cs | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Ct_inl = var_Ct | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Hd_inl = var_Hd | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Hn_inl = var_Hn | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Ho_inl = var_Ho | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Hp_inl = var_Hp | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Hs_inl = var_Hs | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Rd_inl = var_Rd | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Rl_inl = var_Rl | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Ro_inl = var_Ro | prepend: math_inl_enter | append: math_inl_leave -%}

<section>
   <p>
      There are a lot of people out on the web who are willing to share raycasting code, 
      but not a whole lot of them bother to actually apply a permissive license to it so 
      that people can legally use it. What's more, a lot of them don't explain how they 
      actually derived the math involved either.
   </p>
   <p>
      Here, I'm going to walk through how to put together a ray/cylinder intersection test. 
      I've also provided code at the bottom as a public domain work.
   </p>
</section>

<section>
   <h2><a name="parametric"></a>Parametric surface of a cylinder</h2>
   <p>
      The parametric equations (that is, equations with parameters) for a cylinder are as follows:
   </p>
   <lu-math>
      <m-givens>
         <label>Given:</label>
         <dl>
            <dt>{{var_Ch}}</dt>
            <m-sep> = </m-sep>
               <dd>height of the cylinder</dd>
            <dt>{{var_Cr}}</dt>
            <m-sep> = </m-sep>
               <dd>radius of the cylinder</dd>
            <dt>{{var_Ho}}</dt>
            <m-sep> = </m-sep>
               <dd>height offset on the range [0, {{var_Ch}}], where 0 is aligned with an endcap</dd>
            <dt><var>&theta;</var></dt>
            <m-sep> = </m-sep>
               <dd>any angle, basically</dd>
         </dl>
      </m-givens>
      <m-layout-left>
         {{lu_math_eq_numbers[1]}}
         
         <m-row>
            <m-function-def>
               <m-name>f<sub>x</sub></m-name><!--
            --><m-args><!--
               --><m-delim>(</m-delim>
                     <m-arg>{{var_Ho}}</m-arg>
                  <m-sep>, </m-sep>
                     <m-arg><var>&theta;</var></m-arg>
                  <m-delim>)</m-delim><!--
            --></m-args>
            </m-function-def>
            =
            {{var_Cr}} &times; cos(<var>&theta;</var>)
         </m-row>
         <m-row>
            <m-function-def>
               <m-name>f<sub>y</sub></m-name><!--
            --><m-args><!--
               --><m-delim>(</m-delim>
                     <m-arg>{{var_Ho}}</m-arg>
                  <m-sep>, </m-sep>
                     <m-arg><var>&theta;</var></m-arg>
                  <m-delim>)</m-delim><!--
            --></m-args>
            </m-function-def>
            =
            {{var_Cr}} &times; sin(<var>&theta;</var>)
         </m-row>
         <m-row>
            <m-function-def>
               <m-name>f<sub>z</sub></m-name><!--
            --><m-args><!--
               --><m-delim>(</m-delim>
                     <m-arg>{{var_Ho}}</m-arg>
                  <m-sep>, </m-sep>
                     <m-arg><var>&theta;</var></m-arg>
                  <m-delim>)</m-delim><!--
            --></m-args>
            </m-function-def>
            =
            {{var_Ho}}
         </m-row>
      </m-layout-left>
   </lu-math>
   <p>
      Technically, these equations describe an infinite cylinder &mdash; one with no endcaps, which extends forever in both directions. However, we can still use them to put together the tests for a finite clinder with endcaps.
   </p>
   <p>
      You may notice that these are very similar to the parametric equations <a href="{% link _articles/ray-cone-intersection.html %}">for a cone</a>. Mathematically speaking, a cylinder is basically a cone with infinite height, and geometrically speaking, a cylinder is just a cone that never tapers. Moreover, if we ignore the Z-component, then we're literally just writing the equation for a 2D circle.
   </p>
</section>

<section>
   <h2><a name="implicit">Implicit surface of a cylinder</a></h2>
   <p>
      We have a <dfn>parametric surface</dfn> &mdash; that is, three parametric equations which define all points on the surface of the cylinder. In order to solve for any given part of the equation, however, we need an <dfn>implicit surface</dfn>: a surface defined by a single equation, wherein <lu-math data-inline><var>x</var></lu-math>, <lu-math data-inline><var>y</var></lu-math>, and <lu-math data-inline><var>z</var></lu-math> are on one side, and 0 is on the other side.
   </p>
   <p>
      The above equations basically define a 2D circle anchored at <lu-math data-inline>(0, 0)</lu-math> on the XY-plane, and then extend it infinitely along the Z-axis. The circle's radius is {{var_Cr_inl}}. This means that we can represent the X and Y equations in terms of any arbitrary 2D vector <lu-math data-inline><var data-type="vector">P<sub>2D</sub></var></lu-math>:
   </p>
   <lu-math>
      {{lu_math_eq_numbers[2]}}
      
      {{lu_math_vec_start}}<var data-type="vector">P<sub>2D</sub></var>{{lu_math_vec_end}}
      =
      <var>C<sub>r</sub></var>
   </lu-math>
   <p>
      If we project a 3D vector <lu-math data-inline><var data-type="vector">P</var></lu-math> onto the Z-axis, then we'll have just its Z-component. Remove that component, and we can then fit it into the equation above.
   </p>
   <lu-math>
      <m-givens>
         <label>Given:</label>
         <dl>
            <dt><var data-type="vector">P</var></dt>
            <m-sep> = </m-sep>
               <dd>any point on the curved surface of the infinite cylinder</dd>
            <dt>{{var_Ca}}</dt>
            <m-sep> = </m-sep>
               <dd>axis of the cylinder; in this case, (0, 0, 1)</dd>
            <dt><var data-type="vector">P<sub>s</sub></var></dt>
            <m-sep> = </m-sep>
               <dd><var data-type="vector">P</var> projected onto {{var_Ca}}</dd>
         </dl>
      </m-givens>
      <m-row>
         <var data-type="vector">P<sub>s</sub></var>
          = 
         (<var data-type="vector">P</var> &bullet; {{var_Ca}}){{var_Ca}}
      </m-row>
      <m-row>
         {{lu_math_eq_numbers[3]}}
         
         {{lu_math_vec_start}}<var>P</var> - <var>P<sub>s</sub></var>{{lu_math_vec_end}}
         =
         {{var_Cr}}
      </m-row>
   </lu-math>
   <p>
      If we so desire, we can now subtract {{var_Cr_inl}} from both sides of the equation in order to have one side contain only zero. As such, this is now an implicit surface, which defines a cylinder that has one endcap centered on <lu-math data-inline>(0, 0, 0)</lu-math>.
   </p>
</section>

<section>
   <h2><a name="transformed">Handling a translated and rotated cylinder</a></h2>
   <p>
      In general, we'll want to run raycasts against a bounded cylinder &mdash; one with endcaps, rather than one that extends infinitely along its axis. There's no equation that can represent a bounded cylinder directly. However, we can still represent an infinite cylinder in terms of where the endcaps <em>would</em> be, and then use some distance checks later to enforce bounds.
   </p>
   <p>
      Let's take the implicit surface of an infinite cylinder, and represent it in terms of the endcaps.
   </p>
   <lu-math>
      <m-givens>
         <label>Given:</label>
         <dl>
            <dt>{{var_Cb}}</dt>
            <m-sep> = </m-sep>
               <dd>centerpoint of the cylinder's bottom endcap</dd>
            <dt>{{var_Ct}}</dt>
            <m-sep> = </m-sep>
               <dd>centerpoint of the cylinder's top endcap</dd>
            <dt>{{var_Cs}}</dt>
            <m-sep> = </m-sep>
               <dd>"spine" of the cylinder: a vector from the top to the bottom, equal to {{var_Ct}} - {{var_Cb}}</dd>
            <dt>{{var_Ca}}</dt>
            <m-sep> = </m-sep>
               <dd>axis of the cylinder: normalized spine</dd>
            <dt>{{var_Hp}}</dt>
            <m-sep> = </m-sep>
               <dd>hit position: a point that we presume is on the cylinder's curved surface</dd>
            <dt>{{var_Hs}}</dt>
            <m-sep> = </m-sep>
               <dd>hit spine position: the hit position projected onto {{var_Cs}}; this position = (({{var_Hp}} - {{var_Cb}}) &bullet; {{var_Ca}}){{var_Ca}} + {{var_Cb}}</dd>
            <dt>{{var_Ho}}</dt>
            <m-sep> = </m-sep>
               <dd>the height offset from our cylinder equations; this is the distance from {{var_Hs}} to {{var_Cb}} i.e. {{lu_math_vec_start}}{{var_Hs}} - {{var_Cb}}{{lu_math_vec_end}}.</dd>
         </dl>
      </m-givens>
   </lu-math>
   <p>
      {{var_Hp_inl}} fills the role of <lu-math data-inline><var data-type="vector">P</var></lu-math> in Equation 3, and {{var_Hs_inl}} fills the role of <lu-math data-inline><var data-type="vector">P<sub>p</sub></var></lu-math>. {{var_Hs_inl}} is the hit position projected onto the cylinder's axis &mdash; its "spine." If we view the cylinder from its endcap, then {{var_Hs_inl}} will be at the center of a circle; if {{var_Hp_inl}} is indeed on the cylinder's curved surface, then the distance from it to {{var_Hs_inl}} will equal the cylinder's radius:
   </p>
   <lu-math>
      <m-row>
         {{lu_math_vec_start}}{{var_Hp}} - {{var_Hs}}{{lu_math_vec_end}}
         =
         {{var_Cr}}
      </m-row>
   </lu-math>
   <p>
      Let's expand {{var_Hs_inl}}.
   </p>
   <lu-math>
      <m-solvestep>
         <m-content>
            {{lu_math_vec_start}}{{var_Hp}} - <mark>((({{var_Hp}} - {{var_Cb}}) &bullet; {{var_Ca}}){{var_Ca}} + {{var_Cb}})</mark>{{lu_math_vec_end}}
            =
            {{var_Cr}}
         </m-content>
      </m-solvestep>
      <m-solvestep>
         {{lu_math_eq_numbers[4]}}
         
         <m-content>
            {{lu_math_vec_start}}{{var_Hp}}<mark>{{dont_eat_this_space}} - {{var_Cb}}</mark> - (({{var_Hp}} - {{var_Cb}}) &bullet; {{var_Ca}}){{var_Ca}}{{lu_math_vec_end}}
            =
            {{var_Cr}}
         </m-content>
      </m-solvestep>
   </lu-math>
</section>

<section>
   <h2><a name="solving">Solving for the ray</a></h2>
   <p>
      A ray is commonly defined in terms of a starting point, or <dfn>origin</dfn>, and a normalized direction vector. We can therefore define the hit position in terms of the same.
   </p>
   <lu-math>
      <m-givens>
         <label>Given:</label>
         <dl>
            <dt>{{var_Ro}}</dt>
            <m-sep> = </m-sep>
               <dd>the ray's origin</dd>
            <dt>{{var_Rd}}</dt>
            <m-sep> = </m-sep>
               <dd>the ray's direction</dd>
            <dt>{{var_Hp}}</dt>
            <m-sep> = </m-sep>
               <dd>the position at which the ray hits some surface</dd>
            <dt>{{var_Hd}}</dt>
            <m-sep> = </m-sep>
               <dd>the hit distance: the distance from the ray origin to the hit position</dd>
         </dl>
      </m-givens>
      <m-row>
         {{var_Hp}} = {{var_Ro}} + {{var_Rd}}{{var_Hd}}
      </m-row>
   </lu-math>
   <p>
      We can substitute this equation into our cylinder equation above, and then attempt to solve for the hit distance {{var_Hd_inl}}:
   </p>
   <lu-math>
      <m-solvestep>
         <m-content>
            {{lu_math_vec_start}}<mark>{{var_Ro}} + {{var_Rd}}{{var_Hd}}</mark>
          - {{var_Cb}}
          - ((<mark>{{var_Ro}} + {{var_Rd}}{{var_Hd}}</mark> - {{var_Cb}}) &bullet; {{var_Ca}}){{var_Ca}}{{lu_math_vec_end}}
            =
            {{var_Cr}}
         </m-content>
      </m-solvestep>
   </lu-math>
   <p>
      We can simplify our problem if we translate the entire coordinate system &mdash; move everything so that the base of the cylinder is <lu-math data-inline>(0, 0, 0)</lu-math>. We'll do that by defining a new variable.
   </p>
   <lu-math>
      <m-givens>
         <label>Given:</label>
         <dl>
            <dt>{{var_Rl}}</dt>
            <m-sep> = </m-sep>
               <dd>the ray's origin relative to the cylinder's base position = {{var_Ro}} - {{var_Cb}}</dd>
         </dl>
      </m-givens>
      <m-solvestep>
         {{lu_math_expl_start}}
            The terms {{var_Ro_inl}} and {{var_Cb_inl}} only appear in two places, and are used the same way: one is subtracted from the other. Combining them into a single term, {{var_Rl_inl}}, will make it easier to manipulate our equation as a whole. You've probably noticed that <lu-math data-inline>{{var_Rd}}{{var_Hd}}</lu-math> works the same way, but remember: we want to solve for {{var_Hd_inl}}, so we need to split it apart from other terms, not merge it into them.
         {{lu_math_expl_end}}
         <m-content>
            {{lu_math_vec_start}}<ins>{{var_Rl}}</ins><del>{{var_Ro}}</del> + {{var_Rd}}{{var_Hd}}<!--
      --><del>{{dont_eat_this_space}} - {{var_Cb}}</del><!--
      --> - ((<ins>{{var_Rl}}</ins><del>{{var_Ro}}</del> + {{var_Rd}}{{var_Hd}}<del>{{dont_eat_this_space}} - {{var_Cb}}</del>) &bullet; {{var_Ca}}){{var_Ca}}{{lu_math_vec_end}}
            =
            {{var_Cr}}
         </m-content>
      </m-solvestep>
   </lu-math>
   <p>
      Now, we can continue working to extricate {{var_Hd}} from the other terms.
   </p>
   <lu-math>
      <m-solvestep>
         {{lu_math_expl_start}}
            If you take the dot product of a vector with itself, the result will be the vector's length squared. This means that if we square both sides of our equation, we can then convert the lefthand side to a dot product.
         {{lu_math_expl_end}}
         <m-content>
            (<!--
            -->{{var_Rl}} + {{var_Rd}}{{var_Hd}}
             - (<!--
               -->({{var_Rl}} + {{var_Rd}}{{var_Hd}}) &bullet; {{var_Ca}}<!--
            -->){{var_Ca}}<!--
         -->)<mark>{{dont_eat_this_space}} &bullet; 
            (<!--
            -->{{var_Rl}} + {{var_Rd}}{{var_Hd}}
             - (<!--
               -->({{var_Rl}} + {{var_Rd}}{{var_Hd}}) &bullet; {{var_Ca}}<!--
            -->){{var_Ca}}<!--
         -->)</mark>
            =
            {{var_Cr}}<mark>{{lu_math_sq}}</mark>
         </m-content>
      </m-solvestep>
      <m-solvestep>
         {{lu_math_expl_start}}
            <p>
               Vector dot products follow most of the same rules as scalar multiplication. This includes being able to expand the multiplication of <dfn>multinomials</dfn> &mdash; groups of <dfn>terms</dfn> assembled via addition and subtraction, where a term is constants or variables that are multiplied by each other (and of course, exponents are just multiplication).
            </p>
            <p>
               When you're squaring a <dfn>quadrinomial</dfn> &mdash; a multinomial with four terms &mdash; the formula looks like this:
            </p>
            <lu-math>
               <m-row>
                  ({{var_Asca}} + {{var_Bsca}} + {{var_Csca}}){{lu_math_sq}}
                  =
                  {{var_Asca}}{{lu_math_sq}} + {{var_Bsca}}{{lu_math_sq}} + {{var_Csca}}{{lu_math_sq}} + 2{{var_Asca}}{{var_Bsca}} + 2{{var_Asca}}{{var_Csca}} + 2{{var_Bsca}}{{var_Csca}}
               </m-row>
            </lu-math>
            <p>
               For our quadrinomial dot product, we have:
            </p>
            <lu-math>
               <m-givens>
                  <dl>
                     <dt>{{var_Asca}}</dt>
                     <m-sep> = </m-sep>
                        <dd>{{var_Rl}}</dd>
                     <dt>{{var_Bsca}}</dt>
                     <m-sep> = </m-sep>
                        <dd>{{var_Rd}}{{var_Hd}}</dd>
                     <dt>{{var_Csca}}</dt>
                     <m-sep> = </m-sep>
                        <dd>
                           -(<!--
                           -->({{var_Rl}} + {{var_Rd}}{{var_Hd}}) &bullet; {{var_Ca}}<!--
                        -->){{var_Ca}}
                        </dd>
                  </dl>
               </m-givens>
            </lu-math>
            <p>
               Of course, when we expand our multinomial, we'll end up with dot products rather than with multiplications.
            </p>
         {{lu_math_expl_end}}
         <m-content>
            <m-layout-snake>
               <m-body>
                  <m-layout-v-segments>
                     <m-segment>
                        ({{var_Rl}} &bullet; {{var_Rl}})
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        ({{var_Rd}}{{var_Hd}} &bullet; {{var_Rd}}{{var_Hd}})
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        <m-raw>(</m-raw><!--
                        -->(<!--
                           -->({{var_Rl}} + {{var_Rd}}{{var_Hd}}) &bullet; {{var_Ca}}<!--
                        -->){{var_Ca}}
                           &bullet;
                           (<!--
                           -->({{var_Rl}} + {{var_Rd}}{{var_Hd}}) &bullet; {{var_Ca}}<!--
                        -->){{var_Ca}}<!--
                     --><m-raw>)</m-raw>
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        2({{var_Rl}} &bullet; {{var_Rd}}{{var_Hd}})
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        2({{var_Rl}} &bullet; (<!--
                        -->({{var_Rl}} + {{var_Rd}}{{var_Hd}}) &bullet; {{var_Ca}}<!--
                     -->){{var_Ca}})
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        2({{var_Rd}}{{var_Hd}} &bullet; (<!--
                        -->({{var_Rl}} + {{var_Rd}}{{var_Hd}}) &bullet; {{var_Ca}}<!--
                     -->){{var_Ca}})
                     </m-segment>
                  </m-layout-v-segments>
               </m-body>
               <m-tail>
                  = {{var_Cr}}{{lu_math_sq}}
               </m-tail>
            </m-layout-snake>
         </m-content>
      </m-solvestep>
      <m-solvestep>
         {{lu_math_expl_start}}
            <p>
               The third term in this equation was the dot product of a big, complicated vector expression with itself &mdash; so, the length squared. However, the vector expression in question,
               <lu-math data-inline>
                  (<!--
                  -->({{var_Rl}} + {{var_Rd}}{{var_Hd}}) &bullet; {{var_Ca}}<!--
               -->){{var_Ca}}
               </lu-math>, is just the projection of the vector 
               <lu-math data-inline>
                  {{var_Rl}} + {{var_Rd}}{{var_Hd}}
               </lu-math>
               onto {{var_Ca_inl}}, where {{var_Ca_inl}} is an axis vector. This means that 
               <lu-math data-inline>
                  ({{var_Rl}} + {{var_Rd}}{{var_Hd}}) &bullet; {{var_Ca}}
               </lu-math>
               is the length of the projected vector. We can cut out the multiplication by {{var_Ca_inl}} entirely, and just square the dot product expression.
            </p>
         {{lu_math_expl_end}}
         <m-content>
            <m-layout-snake>
               <m-body>
                  <m-layout-v-segments>
                     <m-segment>
                        ({{var_Rl}} &bullet; {{var_Rl}})
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        ({{var_Rd}}{{var_Hd}} &bullet; {{var_Rd}}{{var_Hd}})
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        <m-raw>(</m-raw><!--
                        -->(<!--
                           -->({{var_Rl}} + {{var_Rd}}{{var_Hd}}) &bullet; {{var_Ca}}<!--
                        -->)<mark>{{lu_math_sq}}</mark><!--
                     --><m-raw>)</m-raw>
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        2({{var_Rl}} &bullet; {{var_Rd}}{{var_Hd}})
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        2({{var_Rl}} &bullet; (<!--
                        -->({{var_Rl}} + {{var_Rd}}{{var_Hd}}) &bullet; {{var_Ca}}<!--
                     -->){{var_Ca}})
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        2({{var_Rd}}{{var_Hd}} &bullet; (<!--
                        -->({{var_Rl}} + {{var_Rd}}{{var_Hd}}) &bullet; {{var_Ca}}<!--
                     -->){{var_Ca}})
                     </m-segment>
                  </m-layout-v-segments>
               </m-body>
               <m-tail>
                  = {{var_Cr}}{{lu_math_sq}}
               </m-tail>
            </m-layout-snake>
         </m-content>
      </m-solvestep>
      <m-solvestep>
         {{lu_math_expl_start}}
            <p>
               Given vectors {{var_Avec_inl}} and {{var_Bvec_inl}} and scalars {{var_Csca_inl}} and {{var_Dsca_inl}}, it's true that
               <lu-math data-inline>
                  {{var_Avec}}{{var_Csca}} &bullet; {{var_Bvec}}{{var_Dsca}}
                  =
                  ({{var_Avec}} &bullet; {{var_Bvec}}){{var_Csca}}{{var_Dsca}}
               </lu-math>. 
               In this case, {{var_Hd_inl}} and 
               <lu-math data-inline>
                  (({{var_Rl}} + {{var_Rd}}{{var_Hd}}) &bullet; {{var_Ca}})
               </lu-math>
               are the two scalars we're pulling out of a dot product operation.
            </p>
         {{lu_math_expl_end}}
         <m-content>
            <m-layout-snake>
               <m-body>
                  <m-layout-v-segments>
                     <m-segment>
                        ({{var_Rl}} &bullet; {{var_Rl}})
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        ({{var_Rd}}{{var_Hd}} &bullet; {{var_Rd}}{{var_Hd}})
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        <m-raw>(</m-raw><!--
                        -->(<!--
                           -->({{var_Rl}} + {{var_Rd}}{{var_Hd}}) &bullet; {{var_Ca}}<!--
                        -->)<mark>{{lu_math_sq}}</mark><!--
                     --><m-raw>)</m-raw>
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        2({{var_Rl}} &bullet; {{var_Rd}}{{var_Hd}})
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        2({{var_Rl}} &bullet; (<!--
                        -->({{var_Rl}} + {{var_Rd}}{{var_Hd}}) &bullet; {{var_Ca}}<!--
                     -->){{var_Ca}})
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        2(<!--
                        -->{{var_Rd}}<mark class="mark-1"> &bullet; {{var_Ca}}</mark><!--
                     -->)<mark class="mark-2">(({{var_Rl}} + {{var_Rd}}{{var_Hd}}) &bullet; {{var_Ca}}){{var_Hd}}</mark>
                     </m-segment>
                  </m-layout-v-segments>
               </m-body>
               <m-tail>
                  = {{var_Cr}}{{lu_math_sq}}
               </m-tail>
            </m-layout-snake>
         </m-content>
      </m-solvestep>
      <m-solvestep>
         {{lu_math_expl_start}}
            The vector dot product operation is <dfn>distributive across addition</dfn>: given three vectors {{var_Avec_inl}}, {{var_Bvec_inl}}, and {{var_Cvec_inl}}, it will always be the case that <lu-math data-inline>({{var_Avec}} + {{var_Bvec}}) &bullet; {{var_Cvec}} = ({{var_Avec}} &bullet; {{var_Cvec}}) + ({{var_Bvec}} &bullet; {{var_Cvec}})</lu-math>.
         {{lu_math_expl_end}}
         <m-content>
            <m-layout-snake>
               <m-body>
                  <m-layout-v-segments>
                     <m-segment>
                        ({{var_Rl}} &bullet; {{var_Rl}})
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        ({{var_Rd}}{{var_Hd}} &bullet; {{var_Rd}}{{var_Hd}})
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        <m-raw>(</m-raw><!--
                        -->(<!--
                           --><mark>({{var_Ca}} &bullet; {{var_Rl}}) + ({{var_Ca}} &bullet; {{var_Rd}}{{var_Hd}})</mark><!--
                        -->){{lu_math_sq}}<!--
                     --><m-raw>)</m-raw>
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        2({{var_Rl}} &bullet; {{var_Rd}}{{var_Hd}})
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        2({{var_Rl}} &bullet; (<!--
                        --><mark>({{var_Ca}} &bullet; {{var_Rl}}) + ({{var_Ca}} &bullet; {{var_Rd}}{{var_Hd}})</mark><!--
                     -->){{var_Ca}})
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        2(<!--
                        -->{{var_Rd}} &bullet; {{var_Ca}}<!--
                     -->)(<mark>({{var_Ca}} &bullet; {{var_Rl}}) + ({{var_Ca}} &bullet; {{var_Rd}}{{var_Hd}})</mark>){{var_Hd}}
                     </m-segment>
                  </m-layout-v-segments>
               </m-body>
               <m-tail>
                  = {{var_Cr}}{{lu_math_sq}}
               </m-tail>
            </m-layout-snake>
         </m-content>
      </m-solvestep>
      <m-solvestep>
         {{lu_math_expl_start}}
            <lu-math>
               <m-row>
                  2{{var_Asca}}{{var_Bsca}}({{var_Csca}} + {{var_Dsca}})
                  =
                  2{{var_Asca}}{{var_Bsca}}{{var_Csca}}
                  +
                  2{{var_Asca}}{{var_Bsca}}{{var_Dsca}}
               </m-row>
               <m-givens>
                  <dl>
                     <dt>{{var_Asca}}</dt>
                     <m-sep> = </m-sep>
                        <dd>2</dd>
                     <dt>{{var_Bsca}}</dt>
                     <m-sep> = </m-sep>
                        <dd>{{var_Hd}}</dd>
                     <dt>{{var_Csca}}</dt>
                     <m-sep> = </m-sep>
                        <dd>{{var_Ca}} &bullet; {{var_Rl}}</dd>
                     <dt>{{var_Dsca}}</dt>
                     <m-sep> = </m-sep>
                        <dd>{{var_Ca}} &bullet; {{var_Rd}}{{var_Hd}}</dd>
                  </dl>
               </m-givens>
            </lu-math>
         {{lu_math_expl_end}}
         <m-content>
            <m-layout-snake>
               <m-body>
                  <m-layout-v-segments>
                     <m-segment>
                        ({{var_Rl}} &bullet; {{var_Rl}})
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        ({{var_Rd}}{{var_Hd}} &bullet; {{var_Rd}}{{var_Hd}})
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        <m-raw>(</m-raw><!--
                        -->(<!--
                           -->({{var_Ca}} &bullet; {{var_Rl}}) + ({{var_Ca}} &bullet; {{var_Rd}}{{var_Hd}})<!--
                        -->){{lu_math_sq}}<!--
                     --><m-raw>)</m-raw>
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        2({{var_Rl}} &bullet; {{var_Rd}}{{var_Hd}})
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        2({{var_Rl}} &bullet; (<!--
                        -->({{var_Ca}} &bullet; {{var_Rl}}) + ({{var_Ca}} &bullet; {{var_Rd}}{{var_Hd}})<!--
                     -->){{var_Ca}})
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        <mark>2<!--
                     -->({{var_Ca}} &bullet; {{var_Rd}})<!--
                     -->({{var_Ca}} &bullet; {{var_Rl}})<!--
                     -->{{var_Hd}}
                        -
                        2<!--
                     -->({{var_Ca}} &bullet; {{var_Rd}})<!--
                     -->({{var_Ca}} &bullet; {{var_Rd}}{{var_Hd}})<!--
                     -->{{var_Hd}}</mark>
                     </m-segment>
                  </m-layout-v-segments>
               </m-body>
               <m-tail>
                  = {{var_Cr}}{{lu_math_sq}}
               </m-tail>
            </m-layout-snake>
         </m-content>
      </m-solvestep>
      <m-solvestep>
         {{lu_math_expl_start}}
            In a previous step, we took advantage of the fact that 
            <lu-math data-inline>
               {{var_Avec}}{{var_Csca}} &bullet; {{var_Bvec}}{{var_Dsca}}
               =
               ({{var_Avec}} &bullet; {{var_Bvec}}){{var_Csca}}{{var_Dsca}}
            </lu-math>. 
            We can take advantage of this even when there's only one scalar; we just treat the other scalar as 1.
         {{lu_math_expl_end}}
         <m-content>
            <m-layout-snake>
               <m-body>
                  <m-layout-v-segments>
                     <m-segment>
                        ({{var_Rl}} &bullet; {{var_Rl}})
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        ({{var_Rd}} &bullet; {{var_Rd}})<mark>{{var_Hd}}{{lu_math_sq}}</mark>
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        <m-raw>(</m-raw><!--
                        -->(<!--
                           -->({{var_Ca}} &bullet; {{var_Rl}}) + ({{var_Ca}} &bullet; {{var_Rd}})<mark>{{var_Hd}}</mark><!--
                        -->){{lu_math_sq}}<!--
                     --><m-raw>)</m-raw>
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        2({{var_Rd}} &bullet; {{var_Rl}})<mark>{{var_Hd}}</mark>
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        2({{var_Rl}} &bullet; (<!--
                        -->({{var_Ca}} &bullet; {{var_Rl}}) + ({{var_Ca}} &bullet; {{var_Rd}})<mark>{{var_Hd}}</mark><!--
                     -->){{var_Ca}})
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        2<!--
                     -->({{var_Ca}} &bullet; {{var_Rd}})<!--
                     -->({{var_Ca}} &bullet; {{var_Rl}})<!--
                     -->{{var_Hd}}
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        2<!--
                     -->({{var_Ca}} &bullet; {{var_Rd}})<!--
                     -->({{var_Ca}} &bullet; {{var_Rd}})<!--
                     -->{{var_Hd}}<mark>{{lu_math_sq}}</mark>
                     </m-segment>
                  </m-layout-v-segments>
               </m-body>
               <m-tail>
                  = {{var_Cr}}{{lu_math_sq}}
               </m-tail>
            </m-layout-snake>
         </m-content>
      </m-solvestep>
      <m-solvestep>
         {{lu_math_expl_start}}
            More of the same.
         {{lu_math_expl_end}}
         <m-content>
            <m-layout-snake>
               <m-body>
                  <m-layout-v-segments>
                     <m-segment>
                        ({{var_Rl}} &bullet; {{var_Rl}})
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        ({{var_Rd}} &bullet; {{var_Rd}}){{var_Hd}}{{lu_math_sq}}
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        <m-raw>(</m-raw><!--
                        -->(<!--
                           -->({{var_Ca}} &bullet; {{var_Rl}}) + ({{var_Ca}} &bullet; {{var_Rd}}){{var_Hd}}<!--
                        -->){{lu_math_sq}}<!--
                     --><m-raw>)</m-raw>
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        2({{var_Rd}} &bullet; {{var_Rl}}){{var_Hd}}
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        2({{var_Ca}} &bullet; {{var_Rl}})<mark>(<!--
                        -->({{var_Ca}} &bullet; {{var_Rl}}) + ({{var_Ca}} &bullet; {{var_Rd}}){{var_Hd}}<!--
                     -->)</mark>
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        2<!--
                     -->({{var_Ca}} &bullet; {{var_Rd}})<!--
                     -->({{var_Ca}} &bullet; {{var_Rl}})<!--
                     -->{{var_Hd}}
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        2<!--
                     -->({{var_Ca}} &bullet; {{var_Rd}})<!--
                     -->({{var_Ca}} &bullet; {{var_Rd}})<!--
                     -->{{var_Hd}}{{lu_math_sq}}
                     </m-segment>
                  </m-layout-v-segments>
               </m-body>
               <m-tail>
                  = {{var_Cr}}{{lu_math_sq}}
               </m-tail>
            </m-layout-snake>
         </m-content>
      </m-solvestep>
      <m-solvestep>
         {{lu_math_expl_start}}
            <p>
               For the upper row:
            </p>
            <lu-math>
               <m-row>
                  ({{var_Asca}} + {{var_Bsca}}){{lu_math_sq}}
                  =
                  {{var_Asca}}{{lu_math_sq}} + {{var_Bsca}}{{lu_math_sq}} + 2{{var_Asca}}{{var_Bsca}}
               </m-row>
            </lu-math>
            <p>
               For the lower row:
            </p>
            <lu-math>
               <m-row>
                  2{{var_Asca}}{{var_Bsca}}({{var_Csca}} + {{var_Dsca}})
                  =
                  2{{var_Asca}}{{var_Bsca}}{{var_Csca}}
                  +
                  2{{var_Asca}}{{var_Bsca}}{{var_Dsca}}
               </m-row>
               <m-givens>
                  <dl>
                     <dt>{{var_Asca}}</dt>
                     <m-sep> = </m-sep>
                        <dd>-2</dd>
                     <dt>{{var_Bsca}}</dt>
                     <m-sep> = </m-sep>
                        <dd>{{var_Ca}} &bullet; {{var_Rl}}</dd>
                     <dt>{{var_Csca}}</dt>
                     <m-sep> = </m-sep>
                        <dd>{{var_Ca}} &bullet; {{var_Rl}}</dd>
                     <dt>{{var_Dsca}}</dt>
                     <m-sep> = </m-sep>
                        <dd>({{var_Ca}} &bullet; {{var_Rd}}){{var_Hd}}</dd>
                  </dl>
               </m-givens>
            </lu-math>
         {{lu_math_expl_end}}
         <m-content>
            <m-layout-snake>
               <m-body>
                  <m-layout-v-segments>
                     <m-segment>
                        ({{var_Rl}} &bullet; {{var_Rl}})
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        ({{var_Rd}} &bullet; {{var_Rd}}){{var_Hd}}{{lu_math_sq}}
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        ({{var_Ca}} &bullet; {{var_Rl}})<mark class="mark-1">{{lu_math_sq}}</mark>
                        +
                        ({{var_Ca}} &bullet; {{var_Rd}})<mark class="mark-1">{{lu_math_sq}}</mark>{{var_Hd}}<mark class="mark-1">{{lu_math_sq}}</mark>
                        +
                        <mark class="mark-1">2</mark>({{var_Ca}} &bullet; {{var_Rd}})({{var_Ca}} &bullet; {{var_Rl}}){{var_Hd}}
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        2({{var_Rd}} &bullet; {{var_Rl}}){{var_Hd}}
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        <mark class="mark-2">2({{var_Ca}} &bullet; {{var_Rl}})</mark>({{var_Ca}} &bullet; {{var_Rl}})<!--
                     --><mark class="mark-2">{{dont_eat_this_space}} - 
                        2({{var_Ca}} &bullet; {{var_Rl}})</mark>({{var_Ca}} &bullet; {{var_Rd}}){{var_Hd}}
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        2<!--
                     -->({{var_Ca}} &bullet; {{var_Rd}})<!--
                     -->({{var_Ca}} &bullet; {{var_Rl}})<!--
                     -->{{var_Hd}}
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        2<!--
                     -->({{var_Ca}} &bullet; {{var_Rd}})<!--
                     -->({{var_Ca}} &bullet; {{var_Rd}})<!--
                     -->{{var_Hd}}{{lu_math_sq}}
                     </m-segment>
                  </m-layout-v-segments>
               </m-body>
               <m-tail>
                  = {{var_Cr}}{{lu_math_sq}}
               </m-tail>
            </m-layout-snake>
         </m-content>
      </m-solvestep>
      <m-solvestep>
         {{lu_math_expl_start}}
            Rearranging terms, to prepare to combine some of them; and merging some multiplications into squaring.
         {{lu_math_expl_end}}
         <m-content>
            <m-layout-snake>
               <m-body>
                  <m-layout-v-segments>
                     <m-segment>
                        ({{var_Rd}} &bullet; {{var_Rd}}){{var_Hd}}{{lu_math_sq}}
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        ({{var_Ca}} &bullet; {{var_Rd}}){{lu_math_sq}}{{var_Hd}}{{lu_math_sq}}
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        2<!--
                     -->({{var_Ca}} &bullet; {{var_Rd}})<!--
                     -->({{var_Ca}} &bullet; {{var_Rd}})<!--
                     -->{{var_Hd}}{{lu_math_sq}}
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        2({{var_Ca}} &bullet; {{var_Rd}})({{var_Ca}} &bullet; {{var_Rl}}){{var_Hd}}
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        2({{var_Ca}} &bullet; {{var_Rd}})({{var_Ca}} &bullet; {{var_Rl}}){{var_Hd}}
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        2({{var_Ca}} &bullet; {{var_Rd}})({{var_Ca}} &bullet; {{var_Rl}}){{var_Hd}}
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        2({{var_Rd}} &bullet; {{var_Rl}}){{var_Hd}}
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        ({{var_Ca}} &bullet; {{var_Rl}}){{lu_math_sq}}
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        2({{var_Ca}} &bullet; {{var_Rl}}){{lu_math_sq}}
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        ({{var_Rl}} &bullet; {{var_Rl}})
                     </m-segment>
                  </m-layout-v-segments>
               </m-body>
               <m-tail>
                  = {{var_Cr}}{{lu_math_sq}}
               </m-tail>
            </m-layout-snake>
         </m-content>
      </m-solvestep>
      <m-solvestep>
         {{lu_math_expl_start}}
            Some terms cancel each other out; others can be merged; and we can group terms by {{var_Hd_inl}}.
         {{lu_math_expl_end}}
         <m-content>
            <m-layout-snake>
               <m-body>
                  <m-layout-v-segments>
                     <m-segment>
                        (<!--
                        -->({{var_Rd}} &bullet; {{var_Rd}})<!--
                        --><del>{{dont_eat_this_space}} + ({{var_Ca}} &bullet; {{var_Rd}}){{lu_math_sq}}</del><!--
                        -->{{dont_eat_this_space}} - {{dont_eat_this_space}}<!--
                        --><del>2({{var_Ca}} &bullet; {{var_Rd}}){{lu_math_sq}}</del><!--
                        --><ins>({{var_Ca}} &bullet; {{var_Rd}}){{lu_math_sq}}</ins><!--
                     -->){{var_Hd}}{{lu_math_sq}}
                     </m-segment>
                     <m-sep class="del invis"><del class="invis"> + </del></m-sep>
                     <m-segment class="del">
                        <del class="invis">2({{var_Ca}} &bullet; {{var_Rd}})({{var_Ca}} &bullet; {{var_Rl}}){{var_Hd}}</del>
                     </m-segment>
                     <m-sep class="del invis"><del class="invis"> - </del></m-sep>
                     <m-segment class="del">
                        <del class="invis">2({{var_Ca}} &bullet; {{var_Rd}})({{var_Ca}} &bullet; {{var_Rl}}){{var_Hd}}</del>
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        2(<!--
                        -->({{var_Rd}} &bullet; {{var_Rl}})
                           - ({{var_Ca}} &bullet; {{var_Rd}})({{var_Ca}} &bullet; {{var_Rl}})<!--
                     -->){{var_Hd}}
                     </m-segment>
                     <m-sep class="del invis"><del class="invis"> + </del></m-sep>
                     <m-segment class="del">
                        <del class="invis">({{var_Ca}} &bullet; {{var_Rl}}){{lu_math_sq}}</del>
                     </m-segment>
                     <m-sep class="del invis"><del class="invis"> - </del></m-sep>
                     <m-segment class="del">
                        <del class="invis">2({{var_Ca}} &bullet; {{var_Rl}}){{lu_math_sq}}</del>
                     </m-segment>
                     <m-sep class="ins invis"><ins class="invis"> - </ins></m-sep>
                     <m-segment class="ins">
                        <ins class="invis">({{var_Ca}} &bullet; {{var_Rl}}){{lu_math_sq}}</ins>
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        ({{var_Rl}} &bullet; {{var_Rl}})
                     </m-segment>
                  </m-layout-v-segments>
               </m-body>
               <m-tail>
                  = {{var_Cr}}{{lu_math_sq}}
               </m-tail>
            </m-layout-snake>
         </m-content>
      </m-solvestep>
      <m-solvestep>
         <m-content>
            <m-layout-snake>
               <m-body>
                  <m-layout-v-segments>
                     <m-segment>
                        (<!--
                        --><mark>1</mark>
                           -
                           ({{var_Ca}} &bullet; {{var_Rd}}){{lu_math_sq}}<!--
                     -->){{var_Hd}}{{lu_math_sq}}
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        2(<!--
                        -->({{var_Rd}} &bullet; {{var_Rl}})
                           - ({{var_Ca}} &bullet; {{var_Rd}})({{var_Ca}} &bullet; {{var_Rl}})<!--
                     -->){{var_Hd}}
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        ({{var_Ca}} &bullet; {{var_Rl}}){{lu_math_sq}}
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        ({{var_Rl}} &bullet; {{var_Rl}})
                     </m-segment>
                  </m-layout-v-segments>
               </m-body>
               <m-tail>
                  = {{var_Cr}}{{lu_math_sq}}
               </m-tail>
            </m-layout-snake>
         </m-content>
      </m-solvestep>
   </lu-math>
   <p>
      If we arrange that lengthwise, it'll be easier to see that as with ray/cone intersections, we've ended up with a quadratic equation. We can use the quadratic formula to find its <dfn>roots</dfn> &mdash; its solutions; the hit distances.
   </p>
   <lu-math>
      <m-row>
         <mark class="mark-1">{{var_Asca}}</mark><var>x</var>{{lu_math_sq}} + 
         <mark class="mark-2">{{var_Bsca}}</mark><var>x</var> + 
         <mark class="mark-3">{{var_Csca}}</mark>
         = 0
      </m-row>
      <m-row>
         {{lu_math_eq_numbers[5]}}
         
         <mark class="mark-1">(1 - ({{var_Ca}} &bullet; {{var_Rd}}){{lu_math_sq}})</mark>{{var_Hd}}{{lu_math_sq}}
         +
         <mark class="mark-2">2(<!--
         -->({{var_Rd}} &bullet; {{var_Rl}})
            - ({{var_Ca}} &bullet; {{var_Rd}})({{var_Ca}} &bullet; {{var_Rl}})<!--
      -->)</mark>{{var_Hd}}
         +
         <mark class="mark-3">({{var_Rl}} &bullet; {{var_Rl}})
         -
         ({{var_Ca}} &bullet; {{var_Rl}}){{lu_math_sq}} - {{var_Cr}}{{lu_math_sq}}</mark>
         = 0
      </m-row>
      {{lu_math_therefore_block}}
      <m-givens>
         <label>Given:</label>
         <dl>
            <dt>{{var_Asca}}</dt>
            <m-sep> = </m-sep>
               <dd>1 - ({{var_Ca}} &bullet; {{var_Rd}}){{lu_math_sq}}</dd>
            <dt>{{var_Bsca}}</dt>
            <m-sep> = </m-sep>
               <dd>
                  2(<!--
                  -->({{var_Rd}} &bullet; {{var_Rl}})
                     - ({{var_Ca}} &bullet; {{var_Rd}})({{var_Ca}} &bullet; {{var_Rl}})<!--
               -->)
               </dd>
            <dt>{{var_Csca}}</dt>
            <m-sep> = </m-sep>
               <dd>
                  ({{var_Rl}} &bullet; {{var_Rl}})
                  -
                  ({{var_Ca}} &bullet; {{var_Rl}}){{lu_math_sq}} - {{var_Cr}}{{lu_math_sq}}
               </dd>
         </dl>
      </m-givens>
      <m-row>
         {{var_Hd}}
         =
         <m-fraction>
            <m-raw>(</m-raw>
            <m-numer>
               -{{var_Bsca}} &plusmn;
               <m-sqrt><!--
               --><m-raw>&radic;(</m-raw><!--
               
               -->{{var_Bsca}}{{lu_math_sq}} - 4{{var_Asca}}{{var_Csca}}<!--
               
               --><m-raw>)</m-raw>
               </m-sqrt>
            </m-numer>
            <m-raw>) &divide; </m-raw>
            <m-denom>2{{var_Asca}}
            </m-denom>
         </m-fraction>
         <m-rawcap> </m-rawcap>
      </m-row>
   </lu-math>
   <p>
      In the quadratic formula, the expression 
      <lu-math data-inline>{{var_Bsca}}{{lu_math_sq}} - 4{{var_Asca}}{{var_Csca}}</lu-math>
      is called the <dfn>discriminant</dfn>. If its value is negative, then there is no valid solution &mdash; no intersection between the ray and the curved surface of our cylinder. If its value is zero, then there's exactly one solution: you can apply the formula either way (plus or minus) and you'll get the same result. If the discriminant is a positive non-zero number, then there are two different solutions &mdash; two different points at which we have potential intersections.
   </p>
   <p>
      Yes. "Potential." This equation <em>actually</em> tests for intersections between an infinite double-sided line, and an infinitely long cylinder with no endcaps. In order to test for the intersection between a ray and a bounded cylinder, we need to add some additional inequalities, and require that they be true. Let's start with one to rule out any hit positions behind the ray origin:
   </p>
   <lu-math>
      <m-row>
         {{var_Hd}} &geq; 0
      </m-row>
   </lu-math>
   <p>
      Simple enough. Next up, we need to apply bounds to our cylinder. We'll take the vector from the hit position to one of the cylinder's endcaps, project that onto the cylinder's axis, and check the resulting length against the cylinder's height.
   </p>
   <lu-math>
      0
      &leq;
      ({{var_Ct}} - {{var_Hp}}) &bullet; {{var_Ca}}
      &leq;
      {{lu_math_vec_start}}{{var_Ct}} - {{var_Cb}}{{lu_math_vec_end}}
   </lu-math>
   <p>
      There's one more wrinkle: we need to test the ray against the cylinder's endcaps. That'll be two <a href="{% link _articles/ray-disc-intersection.html %}">ray/disc intersection</a> checks. However, since both discs exist on parallel planes, we can actually combine some of the math. Both discs have the same normal vectors, so when we take the dot product of the ray direction with the plane normal, we can reuse that across both ray/disc checks.
   </p>
</section>

<section>
   <h2><a name="free-code">Free code!</a></h2>
   <p>
      The following C++ code is licensed under CC0 (<a href="https://creativecommons.org/publicdomain/zero/1.0/legalcode">full legal text</a> / <a href="https://creativecommons.org/publicdomain/zero/1.0/">summary</a>), and so is effectively a public domain work. You can incorporate it into your programs without the need for attribution, payment, or similar. (That said, linking back here would be polite!)
   </p>
   <p>
      This code makes use of the <a href="https://github.com/g-truc/glm">GLM</a> library for vector math. It has 
      transitive dependencies on some of my other math, in the form of <a href="{% link _articles/ray-disc-intersection.html %}"><code>ray_disc_intersection</code></a> and, through it, <a href="{% link _articles/ray-plane-intersection.html %}"><code>ray_plane_intersection</code></a>.
      </li>
   </ul>
{% highlight cpp %}
//
// Given coefficients in a quadratic equation, this function gives you the roots 
// and returns the number of roots. If there is only one root, then both root 
// variables are set to the same value.
//
int quadratic_roots(
   const float a,
   const float b,
   const float c,
   //
   float& root_lower,
   float& root_upper
) {
   constexpr auto EPSILON = 1e-8;

   float discriminant = (b * b) - (4.0 * a * c);
   if (discriminant > EPSILON) {
      float b_term = b < EPSILON ? -b + sqrt(discriminant) : -b - sqrt(discriminant);

      root_lower = b_term / (2.0 * a); // quadratic formula
      root_upper = (2.0 * c) / b_term; // citardauq formula

      if (root_lower > root_upper)
         std::swap(root_lower, root_upper); // use of both formulae, plus this, avoids catastrophic cancellation due to floating-point limits

      return 2;
   } else if (discriminant > -EPSILON && discriminant <= EPSILON) {
      root_lower = -(b / 2.0 * a);
      root_upper = root_lower;
      return 1;
   }
   root_lower = NAN;
   root_upper = NAN;
   return 0;
}
   
bool ray_cylinder_intersection(
   const glm::vec3& ray_origin,
   const glm::vec3& ray_direction, // must be normalized

   const glm::vec3& cylinder_endcap_t, // centerpoint of a disc on one end of the cylinder
   const glm::vec3& cylinder_endcap_b, // centerpoint of a disc on one end of the cylinder
   const float      cylinder_radius,   // radius of both discs

   const bool hits_from_inside_count,

   float& hit_distance
) {
   //
   // First, identify intersections between a line and an infinite cylinder. An infinite 
   // cylinder has no base and extends in both directions.
   //
   glm::vec3 Rl = ray_origin - cylinder_endcap_b;        // Ray origin local to centerpoint
   glm::vec3 Cs = cylinder_endcap_t - cylinder_endcap_b; // Cylinder spine
   float     Ch = length(Cs);                            // Cylinder height
   glm::vec3 Ca = Cs / Ch;                               // Cylinder axis

   auto Ca_dot_Rd = dot(Ca, ray_direction);
   auto Ca_dot_Rl = dot(Ca, Rl);
   auto Rl_dot_Rl = dot(Rl, Rl);

   float a = 1 - (Ca_dot_Rd * Ca_dot_Rd);
   float b = 2 * (dot(ray_direction, Rl) - Ca_dot_Rd * Ca_dot_Rl);
   float c = Rl_dot_Rl - Ca_dot_Rl * Ca_dot_Rl - (cylinder_radius * cylinder_radius);

   float hit_near;
   float hit_away;
   auto  count = quadratic_roots(a, b, c, hit_near, hit_away);
   if (count == 0) {
      //
      // There is no intersection between a line (i.e. a "double-sided" ray) and the 
      // infinite cylinder that matches our finite cylinder. This means that we cannot 
      // be hitting any part of the cylinder: if we were hitting the base from the 
      // inside, for example, then the "back of our ray" would be hitting the upper 
      // part of the infinite cylinder.
      //
      return false;
   }
   //
   // Now, we need to take our intersection points and ensure that they lie on the 
   // surface of a finite cylinder. If one of them is past the edges of the finite 
   // cylinder, then we need to check for a valid intersection with the endcaps.
   //
   if (count > 2) {
      cobb::unreachable();
   }
   bool valid1 = true;
   bool valid2 = true;
   //
   glm::vec3 Hp1 = ray_origin + ray_direction * hit_near;
   glm::vec3 Hp2 = ray_origin + ray_direction * hit_away;
   float     Ho1 = dot(cylinder_endcap_t - Hp1, Ca); // height offset
   float     Ho2 = dot(cylinder_endcap_t - Hp2, Ca);
   //
   int valid_count = count;
   if (hit_near < 0.0 || Ho1 < 1.0e-8 || Ho1 > Ch) {
      valid1 = false;
      --valid_count;
   }
   if (hit_away < 0.0 || Ho2 < 1.0e-8 || Ho2 > Ch) {
      valid2 = false;
      if (count > 1)
         --valid_count;
   }
   //
   if (valid_count == 0) {
      //
      // The ray never hits the bounded cylinder's curved surface. If we're looking 
      // along the cylinder's axis -- whether from inside or outside -- then the ray 
      // could still hit an endcap.
      // 
      // Let's project the ray origin onto the cylinder's axis, and figure out which 
      // endcap we're nearer to. (Well, actually, we already have that value: it's 
      // Ca_dot_Rl.)
      //
      if (Ca_dot_Rl <= 0.0) { // above
         valid1 = ray_disc_intersection(ray_origin, ray_direction, cylinder_endcap_t, Ca, cylinder_radius, hit_near);
      } else if (Ca_dot_Rl >= Ch) { // below
         valid1 = ray_disc_intersection(ray_origin, ray_direction, cylinder_endcap_b, Ca, cylinder_radius, hit_away);
      } else {
         //
         // Inside. Test both discs.
         //
         if (!hits_from_inside_count) {
            return false;
         }
         valid1 = ray_disc_intersection(ray_origin, ray_direction, cylinder_endcap_t, Ca, cylinder_radius, hit_near);
         valid2 = ray_disc_intersection(ray_origin, ray_direction, cylinder_endcap_b, Ca, cylinder_radius, hit_away);
         if (valid1) {
            if (valid2) {
               if (hit_away < hit_near)
                  hit_near = hit_away;
            }
            hit_distance = hit_near;
            return true;
         } else if (valid2) {
            hit_distance = hit_away;
            return true;
         }
      }
      if (valid1) {
         hit_distance = hit_near;
         return true;
      }
      return false;
   }
   if (valid_count == 1) {
      //
      // The ray hits the cylinder's curved surface only once. This can only happen under 
      // two cases: the ray originates from inside the cylinder, and points outward; or 
      // the ray passes through the bounded cylinder once and then through an endcap.
      //
      if (valid2) {
         Hp1 = Hp2;
         Ho1 = Ho2;
         valid1   = true;
         hit_near = hit_away;
      }

      float disc_near;
      float disc_away;
      bool  disc1 = ray_disc_intersection(ray_origin, ray_direction, cylinder_endcap_t, Ca, cylinder_radius, disc_near);
      bool  disc2 = ray_disc_intersection(ray_origin, ray_direction, cylinder_endcap_b, Ca, cylinder_radius, disc_away);
      if (disc1) {
         if (disc2) {
            if (disc_away < disc_near)
               disc_near = disc_away;
         }
      } else if (disc2) {
         disc_near = hit_away;
         disc1 = disc2;
      }

      if (disc1) {
         if (disc_near < hit_near) {
            hit_distance = disc_near;
            return true;
         }
      } else {
         if (!hits_from_inside_count) {
            //
            // The ray only hits the finite cone's curved surface once, and never hits 
            // the cone's base. This means that the ray must be originating from inside 
            // of the cone.
            //
            return false;
         }
         hit_distance = hit_near;
         return true;
      }
   }
   hit_distance = std::min(hit_near, hit_away);
   return true;
}
{% endhighlight %}
</section>