---
title: Ray/cylinder intersections
tags:
 - 3D
 - geometry
 - intersection
 - math
 - raycasting
social_media:
   description: The math behind doing raycasts for 3D cylinder. Includes public-domain code.
extra_css_files:
 - lu-math2.css
   
---
{%- include lu-math/defines.html -%}

{%- comment -%}

   HTML's whitespace handling works well for prose documents, but falls apart completely when we are, in 
   essence, designing our own markup, as we have for lu-math. Sometimes, we need to be able to GUARANTEE 
   that a given space WON'T be collapsed, without making it a non-breaking space.
   
   One example: having a leading space inside of an inline-block element.  Leading whitespace'll usually 
   be collapsed (y'know, except when it isn't), so using  this variable will slip a dummy element before 
   it so that it's not "leading" anymore.
   
{%- endcomment -%}
{%- assign dont_eat_this_space = "<span></span>" -%}
{%- assign print_one_space = "<span></span>&#32;" -%}

{%- assign lu_math_exps = "" | split: "," -%}
{%- for i in (0..5) -%}
   {%- capture temporary -%}
      <m-exp><span aria-hidden="true"><m-raw>^</m-raw>{{ i }}</span><m-raw data-screen-reader-only>&nbsp;
         {%- case i %}
            {%- when "0", 0 -%}
               to the zeroth power
            {%- when "1", 1 -%}
               to the first power
            {%- when "2", 2 -%}
               squared
            {%- when "3", 3 -%}
               cubed
            {%- else -%}
               to the {{i}}th power
         {%- endcase -%}&nbsp;</m-raw></m-exp>
   {%- endcapture -%}
   {%- assign temporary = temporary | append: "NEVEROCCURRINGSTRING" | split: "NEVEROCCURRINGSTRING" | slice: 0, 1 -%}
   {%- assign lu_math_exps = lu_math_exps | concat: temporary -%}
{%- endfor -%}
{%- assign lu_math_sq = lu_math_exps[2] -%}

{%- comment -%}
   
   Generate convenience variables for lu-math equation numbers. To display equation number 5, for example:
   {{lu_math_eq_numbers[5]}}
   
{%- endcomment -%}
{%- assign lu_math_eq_numbers = "" -%}
{%- for i in (1..20) -%}
   {%- capture temporary -%}
      <m-equation-number>
         <m-rawcap> </m-rawcap>
         <m-raw>[Equation </m-raw><m-value>{{i}}</m-value><m-raw>:]</m-raw>
         <m-rawcap> </m-rawcap>
      </m-equation-number>
   {%- endcapture -%}
   {%- assign temporary = temporary | prepend: "SPLITTER" -%}
   {%- assign lu_math_eq_numbers = lu_math_eq_numbers | append: temporary -%}
{%- endfor -%}
{%- assign lu_math_eq_numbers = lu_math_eq_numbers | split: "SPLITTER" -%}

{%- comment -%}

   Generate convenience variables for the start and end of a solvestep explanation.

{%- endcomment -%}
{%- capture temporary -%}
   <details class="explanation">
      <summary class="toggle-explanation">info</summary>
      <aside>
         %CONTENT%
      </aside>
   </details>
{%- endcapture -%}
{%- assign temporary = temporary | split: "%CONTENT%" -%}
{%- assign lu_math_expl_start = temporary[0] -%}
{%- assign lu_math_expl_end   = temporary[1] -%}

{%- comment -%}
   
   Generate convenience variables for vector-length start and end tags. It is imperative that no whitespace 
   be present in these variables.
   
{%- endcomment -%}
{%- capture temporary -%}
   <m-veclength>
      <m-delim>||</m-delim>
      <m-content>%CONTENT%</m-content>
      <m-delim>||</m-delim>
   </m-veclength>
{%- endcapture -%}
{%- assign temporary  = temporary | strip_newlines | strip | split: " " -%}
{%- assign temporary2 = "" -%}
{%- assign temporary3 = false -%} {%- comment -%} In tag? {%- endcomment -%}
{%- assign temporary4 = false -%}
{%-comment-%}
   Comments so Notepad++'s syntax highlighter doesn't choke.
   <!--
{%-endcomment-%}
{%- for item in temporary -%}
   {%- assign temporary2 = temporary2 | append: item -%}
{%- endfor -%}
{%-comment-%}
   -->
   End of syntax highlighter comment.
{%-endcomment-%}
{%- assign temporary = temporary2 | split: "%CONTENT%" -%}
{%- assign lu_math_vec_start = temporary[0] -%}
{%- assign lu_math_vec_end = temporary[1] -%}

{%- capture lu_math_therefore_block -%}
   <m-therefore data-block>
      <span aria-hidden="true" title="therefore">&therefore;</span>
      <m-raw data-screen-reader-only>&therefore;</m-raw>
   </m-therefore>
{%- endcapture -%}

{%- assign math_inl_enter = "<lu-math data-inline>" -%}
{%- assign math_inl_leave = "</lu-math>" -%}
{%- assign var_Ca     = "<var data-type='vector'>C<sub>a</sub></var>" -%}
{%- assign var_Cb     = "<var data-type='vector'>C<sub>b</sub></var>" -%}
{%- assign var_Ch     = "<var>C<sub>h</sub></var>" -%}
{%- assign var_Cr     = "<var>C<sub>r</sub></var>" -%}
{%- assign var_Cs     = "<var data-type='vector'>C<sub>s</sub></var>" -%}
{%- assign var_Ct     = "<var data-type='vector'>C<sub>t</sub></var>" -%}
{%- assign var_Hd     = "<var>H<sub>d</sub></var>" -%}
{%- assign var_Hn     = "<var data-type='vector'>H<sub>n</sub></var>" -%}
{%- assign var_Ho     = "<var>H<sub>o</sub></var>" -%}
{%- assign var_Hp     = "<var data-type='vector'>H<sub>p</sub></var>" -%}
{%- assign var_Hs     = "<var data-type='vector'>H<sub>s</sub></var>" -%}
{%- assign var_Rd     = "<var data-type='vector'>R<sub>d</sub></var>" -%}
{%- assign var_Rl     = "<var data-type='vector'>R<sub>l</sub></var>" -%}
{%- assign var_Ro     = "<var data-type='vector'>R<sub>o</sub></var>" -%}
{%- assign var_Ca_inl = var_Ca | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Cb_inl = var_Cb | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Ch_inl = var_Ch | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Cr_inl = var_Cr | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Cs_inl = var_Cs | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Ct_inl = var_Ct | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Hd_inl = var_Hd | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Hn_inl = var_Hn | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Ho_inl = var_Ho | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Hp_inl = var_Hp | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Hs_inl = var_Hs | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Rd_inl = var_Rd | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Rl_inl = var_Rl | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Ro_inl = var_Ro | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Avec     = "<var data-type='vector'>A</var>" -%}
{%- assign var_Bvec     = "<var data-type='vector'>B</var>" -%}
{%- assign var_Cvec     = "<var data-type='vector'>C</var>" -%}
{%- assign var_Dvec     = "<var data-type='vector'>D</var>" -%}
{%- assign var_Asca     = "<var>a</var>" -%}
{%- assign var_Bsca     = "<var>b</var>" -%}
{%- assign var_Csca     = "<var>c</var>" -%}
{%- assign var_Dsca     = "<var>d</var>" -%}
{%- assign var_Avec_inl = var_Avec | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Bvec_inl = var_Bvec | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Cvec_inl = var_Cvec | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Csca_inl = var_Csca | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Dsca_inl = var_Dsca | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Asca_inl = var_Asca | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Bsca_inl = var_Bsca | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Csca_inl = var_Csca | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Dsca_inl = var_Dsca | prepend: math_inl_enter | append: math_inl_leave -%}

{%- capture graph_rel_url -%}
   {%- comment -%}
      We want to strip the file extension off of the path to this current article, if it 
      has one (this will depend on the permalink).
   {%- endcomment -%}
   {%- assign temporary = page.url | split: "." -%}
   {{- page.dir -}}
   {%- if temporary.size > 1 -%}
      {%- for item in temporary -%}
         {%- unless forloop.last -%}{{ item }}{%- endunless -%}
      {%- endfor -%}
   {%- else -%}
      {{ temporary[0] }}
   {%- endif -%}
   {%- comment -%}
      Next, we add the name of the asset file we want.
   {%- endcomment -%}
   /line-graph-utils.svg
{%- endcapture -%}
{%- assign graph_rel_url = graph_rel_url -%}

<section>
   <p>
      There are a lot of people out on the web who are willing to share raycasting code, 
      but not a whole lot of them bother to actually apply a permissive license to it so 
      that people can legally use it. What's more, a lot of them don't explain how they 
      actually derived the math involved either.
   </p>
   <p>
      Here, I'm going to walk through how to put together a ray/cylinder intersection test. 
      I've also provided code at the bottom as a public domain work.
   </p>
</section>

<section>
   <h2><a name="parametric"></a>Parametric surface of a cylinder</h2>
   <p>
      The parametric equations (that is, equations with parameters) for a cylinder are as follows:
   </p>
   <lu-math>
      <m-givens>
         <label>Given:</label>
         <dl>
            <dt>{{var_Ch}}</dt>
            <m-sep> = </m-sep>
               <dd>height of the cylinder</dd>
            <dt>{{var_Cr}}</dt>
            <m-sep> = </m-sep>
               <dd>radius of the cylinder</dd>
            <dt>{{var_Ho}}</dt>
            <m-sep> = </m-sep>
               <dd>height offset on the range [0, {{var_Ch}}], where 0 is aligned with an endcap</dd>
            <dt><var>&theta;</var></dt>
            <m-sep> = </m-sep>
               <dd>any angle, basically</dd>
         </dl>
      </m-givens>
      <m-layout-left>
         {{lu_math_eq_numbers[1]}}
         <m-row>
            <m-function-def>
               <m-name>f<sub>x</sub></m-name><!--
            --><m-args><!--
               --><m-delim>(</m-delim>
                     <m-arg>{{var_Ho}}</m-arg>
                  <m-sep>, </m-sep>
                     <m-arg><var>&theta;</var></m-arg>
                  <m-delim>)</m-delim><!--
            --></m-args>
            </m-function-def>
            =
            {{var_Cr}} &times; cos(<var>&theta;</var>)
         </m-row>
         <m-row>
            <m-function-def>
               <m-name>f<sub>y</sub></m-name><!--
            --><m-args><!--
               --><m-delim>(</m-delim>
                     <m-arg>{{var_Ho}}</m-arg>
                  <m-sep>, </m-sep>
                     <m-arg><var>&theta;</var></m-arg>
                  <m-delim>)</m-delim><!--
            --></m-args>
            </m-function-def>
            =
            {{var_Cr}} &times; sin(<var>&theta;</var>)
         </m-row>
         <m-row>
            <m-function-def>
               <m-name>f<sub>z</sub></m-name><!--
            --><m-args><!--
               --><m-delim>(</m-delim>
                     <m-arg>{{var_Ho}}</m-arg>
                  <m-sep>, </m-sep>
                     <m-arg><var>&theta;</var></m-arg>
                  <m-delim>)</m-delim><!--
            --></m-args>
            </m-function-def>
            =
            {{var_Ho}}
         </m-row>
      </m-layout-left>
   </lu-math>
   <p>
      Technically, these equations describe an infinite cylinder &mdash; one with no endcaps, which extends forever in both directions. However, we can still use them to put together the tests for a finite clinder with endcaps.
   </p>
   <p>
      You may notice that these are very similar to the parametric equations <a href="{% link _articles/ray-cone-intersection.html %}">for a cone</a>. Mathematically speaking, a cylinder is basically a cone with infinite height, and geometrically speaking, a cylinder is just a cone that never tapers. Moreover, if we ignore the Z-component, then we're literally just writing the equation for a 2D circle.
   </p>
</section>

<section>
   <h2><a name="implicit">Implicit surface of a cylinder</a></h2>
   <p>
      We have a <dfn>parametric surface</dfn> &mdash; that is, three parametric equations which define all points on the surface of the cylinder. In order to solve for any given part of the equation, however, we need an <dfn>implicit surface</dfn>: a surface defined by a single equation, wherein <lu-math data-inline><var>x</var></lu-math>, <lu-math data-inline><var>y</var></lu-math>, and <lu-math data-inline><var>z</var></lu-math> are on one side, and 0 is on the other side.
   </p>
   <p>
      The above equations basically define a 2D circle anchored at <lu-math data-inline>(0, 0)</lu-math> on the XY-plane, and then extend it infinitely along the Z-axis. The circle's radius is {{var_Cr_inl}}. This means that we can represent the X and Y equations in terms of any arbitrary 2D vector <lu-math data-inline><var data-type="vector">P<sub>2D</sub></var></lu-math>:
   </p>
   <lu-math>
      {{lu_math_eq_numbers[2]}}
      
     {{lu_math_vec_start}}<var data-type="vector">P<sub>2D</sub></var>{{lu_math_vec_end}}
      =
      <var>C<sub>r</sub></var>
   </lu-math>
   <p>
      If we project a 3D vector <lu-math data-inline><var data-type="vector">P</var></lu-math> onto the Z-axis, then we'll have just its Z-component. Remove that component, and we can then fit it into the equation above.
   </p>
   <lu-math>
      <m-givens>
         <label>Given:</label>
         <dl>
            <dt><var data-type="vector">P</var></dt>
            <m-sep> = </m-sep>
               <dd>any point on the curved surface of the infinite cylinder</dd>
            <dt>{{var_Ca}}</dt>
            <m-sep> = </m-sep>
               <dd>axis of the cylinder; in this case, (0, 0, 1)</dd>
            <dt><var data-type="vector">P<sub>s</sub></var></dt>
            <m-sep> = </m-sep>
               <dd><var data-type="vector">P</var> projected onto {{var_Ca}}</dd>
         </dl>
      </m-givens>
      <m-row>
         <var data-type="vector">P<sub>s</sub></var>
          = 
         (<var data-type="vector">P</var> &bullet; {{var_Ca}}){{var_Ca}}
      </m-row>
      <m-row>
         {{lu_math_eq_numbers[3]}}
         
         {{lu_math_vec_start}}<var>P</var> - <var>P<sub>s</sub></var>{{lu_math_vec_end}}
         =
         {{var_Cr}}
      </m-row>
   </lu-math>
   <p>
      If we so desire, we can now subtract {{var_Cr_inl}} from both sides of the equation in order to have one side contain only zero. As such, this is now an implicit surface, which defines a cylinder that has one endcap centered on <lu-math data-inline>(0, 0, 0)</lu-math>.
   </p>
</section>

<section>
   <h2><a name="transformed">Handling a translated and rotated cylinder</a></h2>
   <p>
      In general, we'll want to run raycasts against a bounded cylinder &mdash; one with endcaps, rather than one that extends infinitely along its axis. There's no equation that can represent a bounded cylinder directly. However, we can still represent an infinite cylinder in terms of where the endcaps <em>would</em> be, and then use some distance checks later to enforce bounds.
   </p>
   <p>
      Let's take the implicit surface of an infinite cylinder, and represent it in terms of the endcaps.
   </p>
   <lu-math>
      <m-givens>
         <label>Given:</label>
         <dl>
            <dt>{{var_Cb}}</dt>
            <m-sep> = </m-sep>
               <dd>centerpoint of the cylinder's bottom endcap</dd>
            <dt>{{var_Ct}}</dt>
            <m-sep> = </m-sep>
               <dd>centerpoint of the cylinder's top endcap</dd>
            <dt>{{var_Cs}}</dt>
            <m-sep> = </m-sep>
               <dd>"spine" of the cylinder: a vector from the top to the bottom, equal to {{var_Ct}} - {{var_Cb}}</dd>
            <dt>{{var_Ca}}</dt>
            <m-sep> = </m-sep>
               <dd>axis of the cylinder: normalized spine</dd>
            <dt>{{var_Hp}}</dt>
            <m-sep> = </m-sep>
               <dd>hit position: a point that we presume is on the cylinder's curved surface</dd>
            <dt>{{var_Hs}}</dt>
            <m-sep> = </m-sep>
               <dd>hit spine position: the hit position projected onto {{var_Cs}}; this position = (({{var_Hp}} - {{var_Cb}}) &bullet; {{var_Ca}}){{var_Ca}} + {{var_Cb}}</dd>
            <dt>{{var_Ho}}</dt>
            <m-sep> = </m-sep>
               <dd>the height offset from our cylinder equations; this is the distance from {{var_Hs}} to {{var_Cb}} i.e. {{lu_math_vec_start}}{{var_Hs}} - {{var_Cb}}{{lu_math_vec_end}}.</dd>
         </dl>
      </m-givens>
   </lu-math>
   <p>
      {{var_Hp_inl}} fills the role of <lu-math data-inline><var data-type="vector">P</var></lu-math> in Equation 3, and {{var_Hs_inl}} fills the role of <lu-math data-inline><var data-type="vector">P<sub>p</sub></var></lu-math>. {{var_Hs_inl}} is the hit position projected onto the cylinder's axis &mdash; its "spine." If we view the cylinder from its endcap, then {{var_Hs_inl}} will be at the center of a circle; if {{var_Hp_inl}} is indeed on the cylinder's curved surface, then the distance from it to {{var_Hs_inl}} will equal the cylinder's radius:
   </p>
   <lu-math>
      <m-row>
         {{lu_math_vec_start}}{{var_Hp}} - {{var_Hs}}{{lu_math_vec_end}}
         =
         {{var_Cr}}
      </m-row>
   </lu-math>
   <p>
      Let's expand {{var_Hs_inl}}.
   </p>
   <lu-math>
      <m-solvestep>
         <m-content>
            {{lu_math_vec_start}}{{var_Hp}} - <mark>((({{var_Hp}} - {{var_Cb}}) &bullet; {{var_Ca}}){{var_Ca}} + {{var_Cb}})</mark>{{lu_math_vec_end}}
            =
            {{var_Cr}}
         </m-content>
      </m-solvestep>
      <m-solvestep>
         {{lu_math_eq_numbers[4]}}
         
         <m-content>
            {{lu_math_vec_start}}{{var_Hp}}<mark>{{dont_eat_this_space}} - {{var_Cb}}</mark> - (({{var_Hp}} - {{var_Cb}}) &bullet; {{var_Ca}}){{var_Ca}}{{lu_math_vec_end}}
            =
            {{var_Cr}}
         </m-content>
      </m-solvestep>
   </lu-math>
</section>

<section>
   <h2><a name="solving">Solving for the ray</a></h2>
   <p>
      A ray is commonly defined in terms of a starting point, or <dfn>origin</dfn>, and a normalized direction vector. We can therefore define the hit position in terms of the same.
   </p>
   <lu-math>
      <m-givens>
         <label>Given:</label>
         <dl>
            <dt>{{var_Ro}}</dt>
            <m-sep> = </m-sep>
               <dd>the ray's origin</dd>
            <dt>{{var_Rd}}</dt>
            <m-sep> = </m-sep>
               <dd>the ray's direction</dd>
            <dt>{{var_Hp}}</dt>
            <m-sep> = </m-sep>
               <dd>the position at which the ray hits some surface</dd>
            <dt>{{var_Hd}}</dt>
            <m-sep> = </m-sep>
               <dd>the hit distance: the distance from the ray origin to the hit position</dd>
         </dl>
      </m-givens>
      <m-row>
         {{var_Hp}} = {{var_Ro}} + {{var_Rd}}{{var_Hd}}
      </m-row>
   </lu-math>
   <p>
      We can substitute this equation into our cylinder equation above, and then attempt to solve for the hit distance {{var_Hd_inl}}:
   </p>
   <lu-math>
      <m-solvestep>
         <m-content>
            {{lu_math_vec_start}}<mark>{{var_Ro}} + {{var_Rd}}{{var_Hd}}</mark>
          - {{var_Cb}}
          - ((<mark>{{var_Ro}} + {{var_Rd}}{{var_Hd}}</mark> - {{var_Cb}}) &bullet; {{var_Ca}}){{var_Ca}}{{lu_math_vec_end}}
            =
            {{var_Cr}}
         </m-content>
      </m-solvestep>
   </lu-math>
   <p>
      We can simplify our problem if we translate the entire coordinate system &mdash; move everything so that the base of the cylinder is <lu-math data-inline>(0, 0, 0)</lu-math>. We'll do that by defining a new variable.
   </p>
   <lu-math>
      <m-givens>
         <label>Given:</label>
         <dl>
            <dt>{{var_Rl}}</dt>
            <m-sep> = </m-sep>
               <dd>the ray's origin relative to the cylinder's base position = {{var_Ro}} - {{var_Cb}}</dd>
         </dl>
      </m-givens>
      <m-solvestep>
         {{lu_math_expl_start}}
            The terms {{var_Ro_inl}} and {{var_Cb_inl}} only appear in two places, and are used the same way: one is subtracted from the other. Combining them into a single term, {{var_Rl_inl}}, will make it easier to manipulate our equation as a whole. You've probably noticed that <lu-math data-inline>{{var_Rd}}{{var_Hd}}</lu-math> works the same way, but remember: we want to solve for {{var_Hd_inl}}, so we need to split it apart from other terms, not merge it into them.
         {{lu_math_expl_end}}
         <m-content>
            {{lu_math_vec_start}}<ins>{{var_Rl}}</ins><del>{{var_Ro}}</del> + {{var_Rd}}{{var_Hd}}<!--
      --><del>{{dont_eat_this_space}} - {{var_Cb}}</del><!--
      --> - ((<ins>{{var_Rl}}</ins><del>{{var_Ro}}</del> + {{var_Rd}}{{var_Hd}}<del>{{dont_eat_this_space}} - {{var_Cb}}</del>) &bullet; {{var_Ca}}){{var_Ca}}{{lu_math_vec_end}}
            =
            {{var_Cr}}
         </m-content>
      </m-solvestep>
   </lu-math>
   <p>
      Now, we can continue working to extricate {{var_Hd}} from the other terms.
   </p>
   <lu-math>
      <m-solvestep>
         {{lu_math_expl_start}}
            If you take the dot product of a vector with itself, the result will be the vector's length squared. This means that if we square both sides of our equation, we can then convert the lefthand side to a dot product.
         {{lu_math_expl_end}}
         <m-content>
            (<!--
            -->{{var_Rl}} + {{var_Rd}}{{var_Hd}}
             - (<!--
               -->({{var_Rl}} + {{var_Rd}}{{var_Hd}}) &bullet; {{var_Ca}}<!--
            -->){{var_Ca}}<!--
         -->)<mark>{{dont_eat_this_space}} &bullet; 
            (<!--
            -->{{var_Rl}} + {{var_Rd}}{{var_Hd}}
             - (<!--
               -->({{var_Rl}} + {{var_Rd}}{{var_Hd}}) &bullet; {{var_Ca}}<!--
            -->){{var_Ca}}<!--
         -->)</mark>
            =
            {{var_Cr}}<mark>{{lu_math_sq}}</mark>
         </m-content>
      </m-solvestep>
      <m-solvestep>
         {{lu_math_expl_start}}
            <p>
               Vector dot products follow most of the same rules as scalar multiplication. This includes being able to expand the multiplication of <dfn>multinomials</dfn> &mdash; groups of <dfn>terms</dfn> assembled via addition and subtraction, where a term is constants or variables that are multiplied by each other (and of course, exponents are just multiplication).
            </p>
            <p>
               When you're squaring a <dfn>quadrinomial</dfn> &mdash; a multinomial with four terms &mdash; the formula looks like this:
            </p>
            <lu-math>
               <m-row>
                  ({{var_Asca}} + {{var_Bsca}} + {{var_Csca}}){{lu_math_sq}}
                  =
                  {{var_Asca}}{{lu_math_sq}} + {{var_Bsca}}{{lu_math_sq}} + {{var_Csca}}{{lu_math_sq}} + 2{{var_Asca}}{{var_Bsca}} + 2{{var_Asca}}{{var_Csca}} + 2{{var_Bsca}}{{var_Csca}}
               </m-row>
            </lu-math>
            <p>
               For our quadrinomial dot product, we have:
            </p>
            <lu-math>
               <m-givens>
                  <dl>
                     <dt>{{var_Asca}}</dt>
                     <m-sep> = </m-sep>
                        <dd>{{var_Rl}}</dd>
                     <dt>{{var_Bsca}}</dt>
                     <m-sep> = </m-sep>
                        <dd>{{var_Rd}}{{var_Hd}}</dd>
                     <dt>{{var_Csca}}</dt>
                     <m-sep> = </m-sep>
                        <dd>
                           -(<!--
                           -->({{var_Rl}} + {{var_Rd}}{{var_Hd}}) &bullet; {{var_Ca}}<!--
                        -->){{var_Ca}}
                        </dd>
                  </dl>
               </m-givens>
            </lu-math>
            <p>
               Of course, when we expand our multinomial, we'll end up with dot products rather than with multiplications.
            </p>
         {{lu_math_expl_end}}
         <m-content>
            <m-layout-snake>
               <m-body>
                  <m-layout-v-segments>
                     <m-segment>
                        ({{var_Rl}} &bullet; {{var_Rl}})
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        ({{var_Rd}}{{var_Hd}} &bullet; {{var_Rd}}{{var_Hd}})
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        <m-raw>(</m-raw><!--
                        -->(<!--
                           -->({{var_Rl}} + {{var_Rd}}{{var_Hd}}) &bullet; {{var_Ca}}<!--
                        -->){{var_Ca}}
                           &bullet;
                           (<!--
                           -->({{var_Rl}} + {{var_Rd}}{{var_Hd}}) &bullet; {{var_Ca}}<!--
                        -->){{var_Ca}}<!--
                     --><m-raw>)</m-raw>
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        2({{var_Rl}} &bullet; {{var_Rd}}{{var_Hd}})
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        2({{var_Rl}} &bullet; (<!--
                        -->({{var_Rl}} + {{var_Rd}}{{var_Hd}}) &bullet; {{var_Ca}}<!--
                     -->){{var_Ca}})
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        2({{var_Rd}}{{var_Hd}} &bullet; (<!--
                        -->({{var_Rl}} + {{var_Rd}}{{var_Hd}}) &bullet; {{var_Ca}}<!--
                     -->){{var_Ca}})
                     </m-segment>
                  </m-layout-v-segments>
               </m-body>
               <m-tail>
                  = {{var_Cr}}{{lu_math_sq}}
               </m-tail>
            </m-layout-snake>
         </m-content>
      </m-solvestep>
      <m-solvestep>
         {{lu_math_expl_start}}
            <p>
               The third term in this equation was the dot product of a big, complicated vector expression with itself &mdash; so, the length squared. However, the vector expression in question is a vector projection: it's the projection of 
               <lu-math data-inline>
                  (<!--
                  -->({{var_Rl}} + {{var_Rd}}{{var_Hd}}) &bullet; {{var_Ca}}<!--
               -->){{var_Ca}}
               </lu-math>
               is just the projection of the vector 
               <lu-math data-inline>
                  {{var_Rl}} + {{var_Rd}}{{var_Hd}}
               </lu-math>
               onto {{var_Ca_inl}}, where {{var_Ca_inl}} is an axis vector. This means that 
               <lu-math data-inline>
                  ({{var_Rl}} + {{var_Rd}}{{var_Hd}}) &bullet; {{var_Ca}}
               </lu-math>
               is the length of the projected vector. We can cut out the multiplication by {{var_Ca_inl}} entirely, and just square the dot product expression.
            </p>
         {{lu_math_expl_end}}
         <m-content>
            <m-layout-snake>
               <m-body>
                  <m-layout-v-segments>
                     <m-segment>
                        ({{var_Rl}} &bullet; {{var_Rl}})
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        ({{var_Rd}}{{var_Hd}} &bullet; {{var_Rd}}{{var_Hd}})
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        <m-raw>(</m-raw><!--
                        -->(<!--
                           -->({{var_Rl}} + {{var_Rd}}{{var_Hd}}) &bullet; {{var_Ca}}<!--
                        -->)<mark>{{lu_math_sq}}</mark><!--
                     --><m-raw>)</m-raw>
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        2({{var_Rl}} &bullet; {{var_Rd}}{{var_Hd}})
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        2({{var_Rl}} &bullet; (<!--
                        -->({{var_Rl}} + {{var_Rd}}{{var_Hd}}) &bullet; {{var_Ca}}<!--
                     -->){{var_Ca}})
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        2({{var_Rd}}{{var_Hd}} &bullet; (<!--
                        -->({{var_Rl}} + {{var_Rd}}{{var_Hd}}) &bullet; {{var_Ca}}<!--
                     -->){{var_Ca}})
                     </m-segment>
                  </m-layout-v-segments>
               </m-body>
               <m-tail>
                  = {{var_Cr}}{{lu_math_sq}}
               </m-tail>
            </m-layout-snake>
         </m-content>
      </m-solvestep>
      <m-solvestep>
         {{lu_math_expl_start}}
            <p>
               Given vectors {{var_Avec_inl}} and {{var_Bvec_inl}} and scalars {{var_Csca_inl}} and {{var_Dsca_inl}}, it's true that
               <lu-math data-inline>
                  {{var_Avec}}{{var_Csca}} &bullet; {{var_Bvec}}{{var_Dsca}}
                  =
                  ({{var_Avec}} &bullet; {{var_Bvec}}){{var_Csca}}{{var_Dsca}}
               </lu-math>. 
               In this case, {{var_Hd_inl}} and 
               <lu-math data-inline>
                  (({{var_Rl}} + {{var_Rd}}{{var_Hd}}) &bullet; {{var_Ca}})
               </lu-math>
               are the two scalars we're pulling out of a dot product operation.
            </p>
         {{lu_math_expl_end}}
         <m-content>
            <m-layout-snake>
               <m-body>
                  <m-layout-v-segments>
                     <m-segment>
                        ({{var_Rl}} &bullet; {{var_Rl}})
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        ({{var_Rd}}{{var_Hd}} &bullet; {{var_Rd}}{{var_Hd}})
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        <m-raw>(</m-raw><!--
                        -->(<!--
                           -->({{var_Rl}} + {{var_Rd}}{{var_Hd}}) &bullet; {{var_Ca}}<!--
                        -->)<mark>{{lu_math_sq}}</mark><!--
                     --><m-raw>)</m-raw>
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        2({{var_Rl}} &bullet; {{var_Rd}}{{var_Hd}})
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        2({{var_Rl}} &bullet; (<!--
                        -->({{var_Rl}} + {{var_Rd}}{{var_Hd}}) &bullet; {{var_Ca}}<!--
                     -->){{var_Ca}})
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        2(<!--
                        -->{{var_Rd}}<mark class="mark-1"> &bullet; {{var_Ca}}</mark><!--
                     -->)<mark class="mark-2">(({{var_Rl}} + {{var_Rd}}{{var_Hd}}) &bullet; {{var_Ca}}){{var_Hd}}</mark>
                     </m-segment>
                  </m-layout-v-segments>
               </m-body>
               <m-tail>
                  = {{var_Cr}}{{lu_math_sq}}
               </m-tail>
            </m-layout-snake>
         </m-content>
      </m-solvestep>
      <m-solvestep>
         {{lu_math_expl_start}}
            The vector dot product operation is <dfn>distributive across addition</dfn>: given three vectors {{var_Avec_inl}}, {{var_Bvec_inl}}, and {{var_Cvec_inl}}, it will always be the case that <lu-math data-inline>({{var_Avec}} + {{var_Bvec}}) &bullet; {{var_Cvec}} = ({{var_Avec}} &bullet; {{var_Cvec}}) + ({{var_Bvec}} &bullet; {{var_Cvec}})</lu-math>.
         {{lu_math_expl_end}}
         <m-content>
            <m-layout-snake>
               <m-body>
                  <m-layout-v-segments>
                     <m-segment>
                        ({{var_Rl}} &bullet; {{var_Rl}})
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        ({{var_Rd}}{{var_Hd}} &bullet; {{var_Rd}}{{var_Hd}})
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        <m-raw>(</m-raw><!--
                        -->(<!--
                           --><mark>({{var_Ca}} &bullet; {{var_Rl}}) + ({{var_Ca}} &bullet; {{var_Rd}}{{var_Hd}})</mark><!--
                        -->){{lu_math_sq}}<!--
                     --><m-raw>)</m-raw>
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        2({{var_Rl}} &bullet; {{var_Rd}}{{var_Hd}})
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        2({{var_Rl}} &bullet; (<!--
                        --><mark>({{var_Ca}} &bullet; {{var_Rl}}) + ({{var_Ca}} &bullet; {{var_Rd}}{{var_Hd}})</mark><!--
                     -->){{var_Ca}})
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        2(<!--
                        -->{{var_Rd}} &bullet; {{var_Ca}}<!--
                     -->)(<mark>({{var_Ca}} &bullet; {{var_Rl}}) + ({{var_Ca}} &bullet; {{var_Rd}}{{var_Hd}})</mark>){{var_Hd}}
                     </m-segment>
                  </m-layout-v-segments>
               </m-body>
               <m-tail>
                  = {{var_Cr}}{{lu_math_sq}}
               </m-tail>
            </m-layout-snake>
         </m-content>
      </m-solvestep>
      <m-solvestep>
         {{lu_math_expl_start}}
            <lu-math>
               <m-row>
                  2{{var_Asca}}{{var_Bsca}}({{var_Csca}} + {{var_Dsca}})
                  =
                  2{{var_Asca}}{{var_Bsca}}{{var_Csca}}
                  +
                  2{{var_Asca}}{{var_Bsca}}{{var_Dsca}}
               </m-row>
               <m-givens>
                  <dl>
                     <dt>{{var_Asca}}</dt>
                     <m-sep> = </m-sep>
                        <dd>2</dd>
                     <dt>{{var_Bsca}}</dt>
                     <m-sep> = </m-sep>
                        <dd>{{var_Hd}}</dd>
                     <dt>{{var_Csca}}</dt>
                     <m-sep> = </m-sep>
                        <dd>{{var_Ca}} &bullet; {{var_Rl}}</dd>
                     <dt>{{var_Dsca}}</dt>
                     <m-sep> = </m-sep>
                        <dd>{{var_Ca}} &bullet; {{var_Rd}}{{var_Hd}}</dd>
                  </dl>
               </m-givens>
            </lu-math>
         {{lu_math_expl_end}}
         <m-content>
            <m-layout-snake>
               <m-body>
                  <m-layout-v-segments>
                     <m-segment>
                        ({{var_Rl}} &bullet; {{var_Rl}})
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        ({{var_Rd}}{{var_Hd}} &bullet; {{var_Rd}}{{var_Hd}})
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        <m-raw>(</m-raw><!--
                        -->(<!--
                           -->({{var_Ca}} &bullet; {{var_Rl}}) + ({{var_Ca}} &bullet; {{var_Rd}}{{var_Hd}})<!--
                        -->){{lu_math_sq}}<!--
                     --><m-raw>)</m-raw>
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        2({{var_Rl}} &bullet; {{var_Rd}}{{var_Hd}})
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        2({{var_Rl}} &bullet; (<!--
                        -->({{var_Ca}} &bullet; {{var_Rl}}) + ({{var_Ca}} &bullet; {{var_Rd}}{{var_Hd}})<!--
                     -->){{var_Ca}})
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        <mark>2<!--
                     -->({{var_Ca}} &bullet; {{var_Rd}})<!--
                     -->({{var_Ca}} &bullet; {{var_Rl}})<!--
                     -->{{var_Hd}}
                        -
                        2<!--
                     -->({{var_Ca}} &bullet; {{var_Rd}})<!--
                     -->({{var_Ca}} &bullet; {{var_Rd}}{{var_Hd}})<!--
                     -->{{var_Hd}}</mark>
                     </m-segment>
                  </m-layout-v-segments>
               </m-body>
               <m-tail>
                  = {{var_Cr}}{{lu_math_sq}}
               </m-tail>
            </m-layout-snake>
         </m-content>
      </m-solvestep>
      <m-solvestep>
         {{lu_math_expl_start}}
            In a previous step, we took advantage of the fact that 
            <lu-math data-inline>
               {{var_Avec}}{{var_Csca}} &bullet; {{var_Bvec}}{{var_Dsca}}
               =
               ({{var_Avec}} &bullet; {{var_Bvec}}){{var_Csca}}{{var_Dsca}}
            </lu-math>. 
            We can take advantage of this even when there's only one scalar; we just treat the other scalar as 1.
         {{lu_math_expl_end}}
         <m-content>
            <m-layout-snake>
               <m-body>
                  <m-layout-v-segments>
                     <m-segment>
                        ({{var_Rl}} &bullet; {{var_Rl}})
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        ({{var_Rd}} &bullet; {{var_Rd}})<mark>{{var_Hd}}{{lu_math_sq}}</mark>
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        <m-raw>(</m-raw><!--
                        -->(<!--
                           -->({{var_Ca}} &bullet; {{var_Rl}}) + ({{var_Ca}} &bullet; {{var_Rd}})<mark>{{var_Hd}}</mark><!--
                        -->){{lu_math_sq}}<!--
                     --><m-raw>)</m-raw>
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        2({{var_Rd}} &bullet; {{var_Rl}})<mark>{{var_Hd}}</mark>
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        2({{var_Rl}} &bullet; (<!--
                        -->({{var_Ca}} &bullet; {{var_Rl}}) + ({{var_Ca}} &bullet; {{var_Rd}})<mark>{{var_Hd}}</mark><!--
                     -->){{var_Ca}})
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        2<!--
                     -->({{var_Ca}} &bullet; {{var_Rd}})<!--
                     -->({{var_Ca}} &bullet; {{var_Rl}})<!--
                     -->{{var_Hd}}
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        2<!--
                     -->({{var_Ca}} &bullet; {{var_Rd}})<!--
                     -->({{var_Ca}} &bullet; {{var_Rd}})<!--
                     -->{{var_Hd}}<mark>{{lu_math_sq}}</mark>
                     </m-segment>
                  </m-layout-v-segments>
               </m-body>
               <m-tail>
                  = {{var_Cr}}{{lu_math_sq}}
               </m-tail>
            </m-layout-snake>
         </m-content>
      </m-solvestep>
      <m-solvestep>
         {{lu_math_expl_start}}
            More of the same.
         {{lu_math_expl_end}}
         <m-content>
            <m-layout-snake>
               <m-body>
                  <m-layout-v-segments>
                     <m-segment>
                        ({{var_Rl}} &bullet; {{var_Rl}})
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        ({{var_Rd}} &bullet; {{var_Rd}}){{var_Hd}}{{lu_math_sq}}
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        <m-raw>(</m-raw><!--
                        -->(<!--
                           -->({{var_Ca}} &bullet; {{var_Rl}}) + ({{var_Ca}} &bullet; {{var_Rd}}){{var_Hd}}<!--
                        -->){{lu_math_sq}}<!--
                     --><m-raw>)</m-raw>
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        2({{var_Rd}} &bullet; {{var_Rl}}){{var_Hd}}
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        2({{var_Ca}} &bullet; {{var_Rl}})<mark>(<!--
                        -->({{var_Ca}} &bullet; {{var_Rl}}) + ({{var_Ca}} &bullet; {{var_Rd}}){{var_Hd}}<!--
                     -->)</mark>
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        2<!--
                     -->({{var_Ca}} &bullet; {{var_Rd}})<!--
                     -->({{var_Ca}} &bullet; {{var_Rl}})<!--
                     -->{{var_Hd}}
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        2<!--
                     -->({{var_Ca}} &bullet; {{var_Rd}})<!--
                     -->({{var_Ca}} &bullet; {{var_Rd}})<!--
                     -->{{var_Hd}}{{lu_math_sq}}
                     </m-segment>
                  </m-layout-v-segments>
               </m-body>
               <m-tail>
                  = {{var_Cr}}{{lu_math_sq}}
               </m-tail>
            </m-layout-snake>
         </m-content>
      </m-solvestep>
      <m-solvestep>
         {{lu_math_expl_start}}
            <p>
               For the upper row:
            </p>
            <lu-math>
               <m-row>
                  ({{var_Asca}} + {{var_Bsca}}){{lu_math_sq}}
                  =
                  {{var_Asca}}{{lu_math_sq}} + {{var_Bsca}}{{lu_math_sq}} + 2{{var_Asca}}{{var_Bsca}}
               </m-row>
            </lu-math>
            <p>
               For the lower row:
            </p>
            <lu-math>
               <m-row>
                  2{{var_Asca}}{{var_Bsca}}({{var_Csca}} + {{var_Dsca}})
                  =
                  2{{var_Asca}}{{var_Bsca}}{{var_Csca}}
                  +
                  2{{var_Asca}}{{var_Bsca}}{{var_Dsca}}
               </m-row>
               <m-givens>
                  <dl>
                     <dt>{{var_Asca}}</dt>
                     <m-sep> = </m-sep>
                        <dd>-2</dd>
                     <dt>{{var_Bsca}}</dt>
                     <m-sep> = </m-sep>
                        <dd>{{var_Ca}} &bullet; {{var_Rl}}</dd>
                     <dt>{{var_Csca}}</dt>
                     <m-sep> = </m-sep>
                        <dd>{{var_Ca}} &bullet; {{var_Rl}}</dd>
                     <dt>{{var_Dsca}}</dt>
                     <m-sep> = </m-sep>
                        <dd>({{var_Ca}} &bullet; {{var_Rd}}){{var_Hd}}</dd>
                  </dl>
               </m-givens>
            </lu-math>
         {{lu_math_expl_end}}
         <m-content>
            <m-layout-snake>
               <m-body>
                  <m-layout-v-segments>
                     <m-segment>
                        ({{var_Rl}} &bullet; {{var_Rl}})
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        ({{var_Rd}} &bullet; {{var_Rd}}){{var_Hd}}{{lu_math_sq}}
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        ({{var_Ca}} &bullet; {{var_Rl}})<mark class="mark-1">{{lu_math_sq}}</mark>
                        +
                        ({{var_Ca}} &bullet; {{var_Rd}})<mark class="mark-1">{{lu_math_sq}}</mark>{{var_Hd}}<mark class="mark-1">{{lu_math_sq}}</mark>
                        +
                        <mark class="mark-1">2</mark>({{var_Ca}} &bullet; {{var_Rd}})({{var_Ca}} &bullet; {{var_Rl}}){{var_Hd}}
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        2({{var_Rd}} &bullet; {{var_Rl}}){{var_Hd}}
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        <mark class="mark-2">2({{var_Ca}} &bullet; {{var_Rl}})</mark>({{var_Ca}} &bullet; {{var_Rl}})<!--
                     --><mark class="mark-2">{{dont_eat_this_space}} - 
                        2({{var_Ca}} &bullet; {{var_Rl}})</mark>({{var_Ca}} &bullet; {{var_Rd}}){{var_Hd}}
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        2<!--
                     -->({{var_Ca}} &bullet; {{var_Rd}})<!--
                     -->({{var_Ca}} &bullet; {{var_Rl}})<!--
                     -->{{var_Hd}}
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        2<!--
                     -->({{var_Ca}} &bullet; {{var_Rd}})<!--
                     -->({{var_Ca}} &bullet; {{var_Rd}})<!--
                     -->{{var_Hd}}{{lu_math_sq}}
                     </m-segment>
                  </m-layout-v-segments>
               </m-body>
               <m-tail>
                  = {{var_Cr}}{{lu_math_sq}}
               </m-tail>
            </m-layout-snake>
         </m-content>
      </m-solvestep>
      <m-solvestep>
         {{lu_math_expl_start}}
            Rearranging terms, to prepare to combine some of them; and merging some multiplications into squaring.
         {{lu_math_expl_end}}
         <m-content>
            <m-layout-snake>
               <m-body>
                  <m-layout-v-segments>
                     <m-segment>
                        ({{var_Rd}} &bullet; {{var_Rd}}){{var_Hd}}{{lu_math_sq}}
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        ({{var_Ca}} &bullet; {{var_Rd}}){{lu_math_sq}}{{var_Hd}}{{lu_math_sq}}
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        2<!--
                     -->({{var_Ca}} &bullet; {{var_Rd}})<!--
                     -->({{var_Ca}} &bullet; {{var_Rd}})<!--
                     -->{{var_Hd}}{{lu_math_sq}}
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        2({{var_Ca}} &bullet; {{var_Rd}})({{var_Ca}} &bullet; {{var_Rl}}){{var_Hd}}
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        2({{var_Ca}} &bullet; {{var_Rd}})({{var_Ca}} &bullet; {{var_Rl}}){{var_Hd}}
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        2({{var_Ca}} &bullet; {{var_Rd}})({{var_Ca}} &bullet; {{var_Rl}}){{var_Hd}}
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        2({{var_Rd}} &bullet; {{var_Rl}}){{var_Hd}}
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        ({{var_Ca}} &bullet; {{var_Rl}}){{lu_math_sq}}
                     </m-segment>
                     <m-sep> - </m-sep>
                     <m-segment>
                        2({{var_Ca}} &bullet; {{var_Rl}}){{lu_math_sq}}
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        ({{var_Rl}} &bullet; {{var_Rl}})
                     </m-segment>
                  </m-layout-v-segments>
               </m-body>
               <m-tail>
                  = {{var_Cr}}{{lu_math_sq}}
               </m-tail>
            </m-layout-snake>
         </m-content>
      </m-solvestep>
      <m-solvestep>
         {{lu_math_expl_start}}
            Some terms cancel each other out; others can be merged; and we can group terms by {{var_Hd_inl}}.
         {{lu_math_expl_end}}
         <m-content>
            <m-layout-snake>
               <m-body>
                  <m-layout-v-segments>
                     <m-segment>
                        (<!--
                        -->({{var_Rd}} &bullet; {{var_Rd}})<!--
                        --><del>{{dont_eat_this_space}} + ({{var_Ca}} &bullet; {{var_Rd}}){{lu_math_sq}}</del><!--
                        -->{{dont_eat_this_space}} - {{dont_eat_this_space}}<!--
                        --><del>2({{var_Ca}} &bullet; {{var_Rd}}){{lu_math_sq}}</del>
                           <ins>({{var_Ca}} &bullet; {{var_Rd}}){{lu_math_sq}}</ins><!--
                     -->){{var_Hd}}{{lu_math_sq}}
                     </m-segment>
                     <m-sep class="del invis"><del class="invis"> + </del></m-sep>
                     <m-segment class="del">
                        <del class="invis">2({{var_Ca}} &bullet; {{var_Rd}})({{var_Ca}} &bullet; {{var_Rl}}){{var_Hd}}</del>
                     </m-segment>
                     <m-sep class="del invis"><del class="invis"> - </del></m-sep>
                     <m-segment class="del">
                        <del class="invis">2({{var_Ca}} &bullet; {{var_Rd}})({{var_Ca}} &bullet; {{var_Rl}}){{var_Hd}}</del>
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        2(<!--
                        -->({{var_Rd}} &bullet; {{var_Rl}})
                           - ({{var_Ca}} &bullet; {{var_Rd}})({{var_Ca}} &bullet; {{var_Rl}})<!--
                     -->){{var_Hd}}
                     </m-segment>
                     <m-sep class="del invis"><del class="invis"> + </del></m-sep>
                     <m-segment class="del">
                        <del class="invis">({{var_Ca}} &bullet; {{var_Rl}}){{lu_math_sq}}</del>
                     </m-segment>
                     <m-sep class="del invis"><del class="invis"> - </del></m-sep>
                     <m-segment class="del">
                        <del class="invis">2({{var_Ca}} &bullet; {{var_Rl}}){{lu_math_sq}}</del>
                     </m-segment>
                     <m-sep class="ins invis"><ins class="invis"> - </del></m-sep>
                     <m-segment class="ins">
                        <ins class="invis">({{var_Ca}} &bullet; {{var_Rl}}){{lu_math_sq}}</ins>
                     </m-segment>
                     <m-sep> + </m-sep>
                     <m-segment>
                        ({{var_Rl}} &bullet; {{var_Rl}})
                     </m-segment>
                  </m-layout-v-segments>
               </m-body>
               <m-tail>
                  = {{var_Cr}}{{lu_math_sq}}
               </m-tail>
            </m-layout-snake>
         </m-content>
      </m-solvestep>
   </lu-math>
   <p>
      Hm... I need to test this.
   </p>
</section>