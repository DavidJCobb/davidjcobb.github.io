---
title: Ray/cylinder intersections
tags:
 - 3D
 - geometry
 - intersection
 - math
 - raycasting
social_media:
   description: The math behind doing raycasts for 3D cylinder. Includes public-domain code.
extra_css_files:
 - lu-math2.css
   
---
{%- include lu-math/defines.html -%}

{%- comment -%}

   HTML's whitespace handling works well for prose documents, but falls apart completely when we are, in 
   essence, designing our own markup, as we have for lu-math. Sometimes, we need to be able to GUARANTEE 
   that a given space WON'T be collapsed, without making it a non-breaking space.
   
   One example: having a leading space inside of an inline-block element.  Leading whitespace'll usually 
   be collapsed (y'know, except when it isn't), so using  this variable will slip a dummy element before 
   it so that it's not "leading" anymore.
   
{%- endcomment -%}
{%- assign dont_eat_this_space = "<span></span>" -%}
{%- assign print_one_space = "<span></span>&#32;" -%}

{%- assign lu_math_exps = "" | split: "," -%}
{%- for i in (0..5) -%}
   {%- capture temporary -%}
      <m-exp><span aria-hidden="true"><m-raw>^</m-raw>{{ i }}</span><m-raw data-screen-reader-only>&nbsp;
         {%- case i %}
            {%- when "0", 0 -%}
               to the zeroth power
            {%- when "1", 1 -%}
               to the first power
            {%- when "2", 2 -%}
               squared
            {%- when "3", 3 -%}
               cubed
            {%- else -%}
               to the {{i}}th power
         {%- endcase -%}&nbsp;</m-raw></m-exp>
   {%- endcapture -%}
   {%- assign temporary = temporary | append: "NEVEROCCURRINGSTRING" | split: "NEVEROCCURRINGSTRING" | slice: 0, 1 -%}
   {%- assign lu_math_exps = lu_math_exps | concat: temporary -%}
{%- endfor -%}
{%- assign lu_math_sq = lu_math_exps[2] -%}

{%- comment -%}
   
   Generate convenience variables for lu-math equation numbers. To display equation number 5, for example:
   {{lu_math_eq_numbers[5]}}
   
{%- endcomment -%}
{%- assign lu_math_eq_numbers = "" -%}
{%- for i in (1..20) -%}
   {%- capture temporary -%}
      <m-equation-number>
         <m-rawcap> </m-rawcap>
         <m-raw>[Equation </m-raw><m-value>{{i}}</m-value><m-raw>:]</m-raw>
         <m-rawcap> </m-rawcap>
      </m-equation-number>
   {%- endcapture -%}
   {%- assign temporary = temporary | prepend: "SPLITTER" -%}
   {%- assign lu_math_eq_numbers = lu_math_eq_numbers | append: temporary -%}
{%- endfor -%}
{%- assign lu_math_eq_numbers = lu_math_eq_numbers | split: "SPLITTER" -%}

{%- comment -%}

   Generate convenience variables for the start and end of a solvestep explanation.

{%- endcomment -%}
{%- capture temporary -%}
   <details class="explanation">
      <summary class="toggle-explanation">info</summary>
      <aside>
         %CONTENT%
      </aside>
   </details>
{%- endcapture -%}
{%- assign temporary = temporary | split: "%CONTENT%" -%}
{%- assign lu_math_expl_start = temporary[0] -%}
{%- assign lu_math_expl_end   = temporary[1] -%}

{%- comment -%}
   
   Generate convenience variables for vector-length start and end tags. It is imperative that no whitespace 
   be present in these variables.
   
{%- endcomment -%}
{%- capture temporary -%}
   <m-veclength>
      <m-delim>||</m-delim>
      <m-content>%CONTENT%</m-content>
      <m-delim>||</m-delim>
   </m-veclength>
{%- endcapture -%}
{%- assign temporary  = temporary | strip_newlines | strip | split: " " -%}
{%- assign temporary2 = "" -%}
{%- assign temporary3 = false -%} {%- comment -%} In tag? {%- endcomment -%}
{%- assign temporary4 = false -%}
{%-comment-%}
   Comments so Notepad++'s syntax highlighter doesn't choke.
   <!--
{%-endcomment-%}
{%- for item in temporary -%}
   {%- assign temporary2 = temporary2 | append: item -%}
{%- endfor -%}
{%-comment-%}
   -->
   End of syntax highlighter comment.
{%-endcomment-%}
{%- assign temporary = temporary2 | split: "%CONTENT%" -%}
{%- assign lu_math_vec_start = temporary[0] -%}
{%- assign lu_math_vec_end = temporary[1] -%}

{%- capture lu_math_therefore_block -%}
   <m-therefore data-block>
      <span aria-hidden="true" title="therefore">&therefore;</span>
      <m-raw data-screen-reader-only>&therefore;</m-raw>
   </m-therefore>
{%- endcapture -%}

{%- assign math_inl_enter = "<lu-math data-inline>" -%}
{%- assign math_inl_leave = "</lu-math>" -%}
{%- assign var_Ca     = "<var data-type='vector'>C<sub>a</sub></var>" -%}
{%- assign var_Cb     = "<var data-type='vector'>C<sub>b</sub></var>" -%}
{%- assign var_Ch     = "<var>C<sub>h</sub></var>" -%}
{%- assign var_Cr     = "<var>C<sub>r</sub></var>" -%}
{%- assign var_Cs     = "<var data-type='vector'>C<sub>s</sub></var>" -%}
{%- assign var_Ct     = "<var data-type='vector'>C<sub>t</sub></var>" -%}
{%- assign var_Hd     = "<var>H<sub>d</sub></var>" -%}
{%- assign var_Hn     = "<var data-type='vector'>H<sub>n</sub></var>" -%}
{%- assign var_Ho     = "<var>H<sub>o</sub></var>" -%}
{%- assign var_Hp     = "<var data-type='vector'>H<sub>p</sub></var>" -%}
{%- assign var_Hs     = "<var data-type='vector'>H<sub>s</sub></var>" -%}
{%- assign var_Ca_inl = var_Ca | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Cb_inl = var_Cb | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Cr_inl = var_Cr | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Cs_inl = var_Cs | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Hd_inl = var_Hd | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Hn_inl = var_Hn | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Hp_inl = var_Hp | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Hs_inl = var_Hs | prepend: math_inl_enter | append: math_inl_leave -%}
<section>
   <p>
      There are a lot of people out on the web who are willing to share raycasting code, 
      but not a whole lot of them bother to actually apply a permissive license to it so 
      that people can legally use it. What's more, a lot of them don't explain how they 
      actually derived the math involved either.
   </p>
   <p>
      Here, I'm going to walk through how to put together a ray/cylinder intersection test. 
      I've also provided code at the bottom as a public domain work.
   </p>
</section>

<section>
   <h2><a name="parametric"></a>Parametric surface of a cylinder</h2>
   <p>
      The parametric equations (that is, equations with parameters) for a cylinder are as follows:
   </p>
   <lu-math>
      <m-givens>
         <label>Given:</label>
         <dl>
            <dt>{{var_Ch}}</dt>
            <m-sep> = </m-sep>
               <dd>height of the cylinder</dd>
            <dt>{{var_Cr}}</dt>
            <m-sep> = </m-sep>
               <dd>radius of the cylinder</dd>
            <dt>{{var_Ho}}</dt>
            <m-sep> = </m-sep>
               <dd>height offset on the range [0, {{var_Ch}}], where 0 is aligned with an endcap</dd>
            <dt><var>&theta;</var></dt>
            <m-sep> = </m-sep>
               <dd>any angle, basically</dd>
         </dl>
      </m-givens>
      <m-layout-left>
         {{lu_math_eq_numbers[1]}}
         <m-row>
            <m-function-def>
               <m-name>f<sub>x</sub></m-name><!--
            --><m-args><!--
               --><m-delim>(</m-delim>
                     <m-arg>{{var_Ho}}</m-arg>
                  <m-sep>, </m-sep>
                     <m-arg><var>&theta;</var></m-arg>
                  <m-delim>)</m-delim><!--
            --></m-args>
            </m-function-def>
            =
            {{var_Cr}} &times; cos(<var>&theta;</var>)
         </m-row>
         <m-row>
            <m-function-def>
               <m-name>f<sub>y</sub></m-name><!--
            --><m-args><!--
               --><m-delim>(</m-delim>
                     <m-arg>{{var_Ho}}</m-arg>
                  <m-sep>, </m-sep>
                     <m-arg><var>&theta;</var></m-arg>
                  <m-delim>)</m-delim><!--
            --></m-args>
            </m-function-def>
            =
            {{var_Cr}} &times; sin(<var>&theta;</var>)
         </m-row>
         <m-row>
            <m-function-def>
               <m-name>f<sub>z</sub></m-name><!--
            --><m-args><!--
               --><m-delim>(</m-delim>
                     <m-arg>{{var_Ho}}</m-arg>
                  <m-sep>, </m-sep>
                     <m-arg><var>&theta;</var></m-arg>
                  <m-delim>)</m-delim><!--
            --></m-args>
            </m-function-def>
            =
            {{var_Ho}}
         </m-row>
      </m-layout-left>
   </lu-math>
   <p>
      Technically, these equations describe an infinite cylinder &mdash; one with no endcaps, which extends forever in both directions. However, we can still use them to put together the tests for a finite clinder with endcaps.
   </p>
   <p>
      You may notice that these are very similar to the parametric equations <a href="{% link _articles/ray-cone-intersection.html %}">for a cone</a>. Mathematically speaking, a cylinder is basically a cone with infinite height, and geometrically speaking, a cylinder is just a cone that never tapers. Moreover, if we ignore the Z-component, then we're literally just writing the equation for a 2D circle.
   </p>
</section>

<section>
   <h2><a name="implicit">Implicit surface of a cylinder</a></h2>
   <p>
      We have a <dfn>parametric surface</dfn> &mdash; that is, three parametric equations which define all points on the surface of the cylinder. In order to solve for any given part of the equation, however, we need an <dfn>implicit surface</dfn>: a surface defined by a single equation, wherein <lu-math data-inline><var>x</var></lu-math>, <lu-math data-inline><var>y</var></lu-math>, and <lu-math data-inline><var>z</var></lu-math> are on one side, and 0 is on the other side.
   </p>
   <p>
      The above equations basically define a 2D circle anchored at <lu-math data-inline>(0, 0)</lu-math> on the XY-plane, and then extend it infinitely along the Z-axis. The circle's radius is {{var_Cr_inl}}. This means that we can represent the X and Y equations in terms of any arbitrary 2D vector <lu-math data-inline><var data-type="vector">P<sub>2D</sub></var></lu-math>:
   </p>
   <lu-math>
      {{lu_math_eq_numbers[2]}}
      
     {{lu_math_vec_start}}<var data-type="vector">P<sub>2D</sub></var>{{lu_math_vec_end}}
      =
      <var>C<sub>r</sub></var>
   </lu-math>
   <p>
      If we project a 3D vector <lu-math data-inline><var data-type="vector">P</var></lu-math> onto the Z-axis, then we'll have just its Z-component. Remove that component, and we can then fit it into the equation above.
   </p>
   <lu-math>
      <m-givens>
         <label>Given:</label>
         <dl>
            <dt><var data-type="vector">P</var></dt>
            <m-sep> = </m-sep>
               <dd>any point on the curved surface of the infinite cylinder</dd>
            <dt>{{var_Ca}}</dt>
            <m-sep> = </m-sep>
               <dd>axis of the cylinder; in this case, (0, 0, 1)</dd>
            <dt><var data-type="vector">P<sub>s</sub></var></dt>
            <m-sep> = </m-sep>
               <dd><var data-type="vector">P</var> projected onto {{var_Ca}}</dd>
         </dl>
      </m-givens>
      <m-row>
         <var data-type="vector">P<sub>s</sub></var>
          = 
         (<var data-type="vector">P</var> &bullet; {{var_Ca}})
         &times;
         {{var_Ca}}
      </m-row>
      <m-row>
         {{lu_math_eq_numbers[3]}}
         
         {{lu_math_vec_start}}<var>P</var> - <var>P<sub>s</sub></var>{{lu_math_vec_end}}
         =
         {{var_Cr}}
      </m-row>
   </lu-math>
   <p>
      If we so desire, we can now subtract {{var_Cr_inl}} from both sides of the equation in order to have one side contain only zero. As such, this is now an implicit surface, which defines a cylinder that has one endcap centered on <lu-math data-inline>(0, 0, 0)</lu-math>.
   </p>
</section>

<section>
   <h2><a name="transformed">Handling a translated and rotated cylinder</a></h2>
   <p>
      In general, we'll want to run raycasts against a bounded cylinder &mdash; one with endcaps, rather than one that extends infinitely along its axis. There's no equation that can represent a bounded cylinder directly. However, we can still represent an infinite cylinder in terms of where the endcaps <em>would</em> be, and then use some distance checks later to enforce bounds.
   </p>
   <p>
      Let's take the implicit surface of an infinite cylinder, and represent it in terms of the endcaps.
   </p>
   <lu-math>
      <m-givens>
         <label>Given:</label>
         <dl>
            <dt>{{var_Cb}}</dt>
            <m-sep> = </m-sep>
               <dd>centerpoint of the cylinder's bottom endcap</dd>
            <dt>{{var_Ct}}</dt>
            <m-sep> = </m-sep>
               <dd>centerpoint of the cylinder's top endcap</dd>
            <dt>{{var_Cs}}</dt>
            <m-sep> = </m-sep>
               <dd>"spine" of the cylinder: a vector from the top to the bottom, equal to {{var_Ct}} - {{var_Cb}}</dd>
            <dt>{{var_Ca}}</dt>
            <m-sep> = </m-sep>
               <dd>axis of the cylinder: normalized spine</dd>
            <dt>{{var_Hp}}</dt>
            <m-sep> = </m-sep>
               <dd>hit position: a point that we presume is on the cylinder's curved surface</dd>
            <dt>{{var_Hs}}</dt>
            <m-sep> = </m-sep>
               <dd>hit spine position: the hit position projected onto {{var_Cs}}; this position = (({{var_Hp}} - {{var_Cb}}) &bullet; {{var_Ca}}){{var_Ca}} + {{var_Cb}}</dd>
            <dt>{{var_Ho}}</dt>
            <m-sep> = </m-sep>
               <dd>the height offset from our cylinder equations; this is the distance from {{var_Hs}} to {{var_Cb}} i.e. {{lu_math_vec_start}}{{var_Hs}} - {{var_Cb}}{{lu_math_vec_end}}.</dd>
         </dl>
      </m-givens>
   </lu-math>
   <p>
      {{var_Hp_inl}} fills the role of <lu-math data-inline><var data-type="vector">P</var></lu-math> in Equation 3, and {{var_Hs_inl}} fills the role of <lu-math data-inline><var data-type="vector">P<sub>p</sub></var></lu-math>. {{var_Hs_inl}} is the hit position projected onto the cylinder's axis &mdash; its "spine." If we view the cylinder from its endcap, then {{var_Hs_inl}} will be at the center of a circle; if {{var_Hp_inl}} is indeed on the cylinder's curved surface, then the distance from it to {{var_Hs_inl}} will equal the cylinder's radius:
   </p>
   <lu-math>
      {{lu_math_eq_numbers[4]}}
      
      <m-row>
         {{lu_math_vec_start}}{{var_Hp}} - {{var_Hs}}{{lu_math_vec_end}}
         =
         {{var_Cr}}
      </m-row>
   </lu-math>
   <p>
      We could try expanding {{var_Hs_inl}} and getting a more complete equation &mdash; something we could plug the equation for our ray into &mdash; but I've actually tried that, and, uh,... it doesn't work so well. We <em>get</em> an equation that we <em>could</em> technically use, but it's huge and inefficient. So instead, let's look at the geometry of the problem and see if we can make any deductions that might help.
   </p>
   <p>
      If the hit position is on the surface, then the vector from {{var_Hs_inl}} to {{var_Hp_inl}} will have the same length as the cylinder's radius. What's more: it will be perpendicular to the cylinder's axis {{var_Ca_inl}}, and parallel to the surface normal vector at the hit position. If we normalize this vector, we <em>get</em> the surface normal. We can add that to our equations: if two vectors are perpendicular, then their cross product will have length 1. Similarly, their dot product will be zero.
   </p>
   <lu-math>
      <m-givens>
         <label>Given:</label>
         <dl>
            <dt>{{var_Hn}}</dt>
            <m-sep> = </m-sep>
               <dd>
                  <span>
                     the surface normal at the hit position =
                  </span>
                  <m-fraction>
                     <m-raw>(</m-raw>
                     <m-numer>{{var_Hp}} - {{var_Hs}}</m-numer>
                     <m-raw> &divide; </m-raw>
                     <m-denom>
                        {{lu_math_vec_start}}{{var_Hp}} - {{var_Hs}}{{lu_math_vec_end}}
                     </m-denom>
                     <m-raw>)</m-raw>
                     <m-rawcap> </m-rawcap>
                  </m-fraction>
               </dd>
         </dl>
      </m-givens>
      <m-row>
         {{lu_math_vec_start}}{{var_Hp}} - {{var_Hs}}{{lu_math_vec_end}}
         =
         <var>C<sub>r</sub></var>
      </m-row>
      <m-row>
         <span>
            {{var_Hn}}
            =
         </span>
         <m-fraction>
            <m-raw>(</m-raw>
            <m-numer>{{var_Hp}} - {{var_Hs}}</m-numer>
            <m-raw> &divide; </m-raw>
            <m-denom>
               {{lu_math_vec_start}}{{var_Hp}} - {{var_Hs}}{{lu_math_vec_end}}
            </m-denom>
            <m-raw>)</m-raw>
            <m-rawcap> </m-rawcap>
         </m-fraction>
         <span>
            =
         </span>
         <m-fraction>
            <m-raw>(</m-raw>
            <m-numer>{{var_Hp}} - {{var_Hs}}</m-numer>
            <m-raw> &divide; </m-raw>
            <m-denom>
               {{var_Cr}}
            </m-denom>
            <m-raw>)</m-raw>
            <m-rawcap> </m-rawcap>
         </m-fraction>
      </m-row>
      <m-row>
         {{lu_math_eq_numbers[5]}}
         
         {{lu_math_vec_start}}{{var_Hn}} &times; {{var_Ca}}{{lu_math_vec_end}}
         =
         1
      </m-row>
      <m-row>
         {{lu_math_eq_numbers[6]}}
         
         {{var_Hn}} &bullet; {{var_Ca}}
         =
         0
      </m-row>
   </lu-math>
   <p>
      Let's expand {{var_Hn_inl}}, and then {{var_Hs_inl}}, in both of these.
   </p>
   <lu-math>
      <m-solvestep>
         <m-content>
            <m-row>
               {{lu_math_vec_start}}
                  <m-fraction>
                     <m-raw>(</m-raw>
                     <m-numer>{{var_Hp}} - {{var_Hs}}</m-numer>
                     <m-raw> &divide; </m-raw>
                     <m-denom>
                        {{var_Cr}}
                     </m-denom>
                     <m-raw>)</m-raw>
                     <m-rawcap> </m-rawcap>
                  </m-fraction>
                  &times;
                  {{var_Ca}}
               {{lu_math_vec_end}}
               =
               1
            </m-row>
            <m-row>
               <m-fraction>
                  <m-raw>(</m-raw>
                  <m-numer>{{var_Hp}} - {{var_Hs}}</m-numer>
                  <m-raw> &divide; </m-raw>
                  <m-denom>
                     {{var_Cr}}
                  </m-denom>
                  <m-raw>)</m-raw>
                  <m-rawcap> </m-rawcap>
               </m-fraction>
               &bullet;
               {{var_Ca}}
               =
               0
            </m-row>
         </m-content>
      </m-solvestep>
      <m-solvestep>
         <m-content>
            <m-row>
               {{lu_math_vec_start}}
                  <m-fraction>
                     <m-raw>(</m-raw>
                     <m-numer>{{var_Hp}} - (({{var_Hp}} - {{var_Cb}}) &bullet; {{var_Ca}}){{var_Ca}} + {{var_Cb}}</m-numer>
                     <m-raw> &divide; </m-raw>
                     <m-denom>
                        {{var_Cr}}
                     </m-denom>
                     <m-raw>)</m-raw>
                     <m-rawcap> </m-rawcap>
                  </m-fraction>
                  &times;
                  {{var_Ca}}
               {{lu_math_vec_end}}
               =
               1
            </m-row>
            <m-row>
               <m-fraction>
                  <m-raw>(</m-raw>
                  <m-numer>{{var_Hp}} - (({{var_Hp}} - {{var_Cb}}) &bullet; {{var_Ca}}){{var_Ca}} + {{var_Cb}}</m-numer>
                  <m-raw> &divide; </m-raw>
                  <m-denom>
                     {{var_Cr}}
                  </m-denom>
                  <m-raw>)</m-raw>
                  <m-rawcap> </m-rawcap>
               </m-fraction>
               &bullet;
               {{var_Ca}}
               =
               0
            </m-row>
         </m-content>
      </m-solvestep>
   </lu-math>
   <p>
      Can we simplify any further?
   </p>
   <lu-math>
      <m-solvestep>
         {{lu_math_expl_start}}
            Distributing the dot product operation over a subtraction.
         {{lu_math_expl_end}}
         <m-content>
            <m-row>
               {{lu_math_vec_start}}
                  <m-fraction>
                     <m-raw>(</m-raw>
                     <m-numer><!--
                     -->{{var_Hp}}
                        -
                        (<!--
                        -->({{var_Hp}} &bullet; {{var_Ca}}) - ({{var_Cb}} &bullet; {{var_Ca}})<!--
                     -->){{var_Ca}}
                        +
                        {{var_Cb}}<!--
                  --></m-numer>
                     <m-raw> &divide; </m-raw>
                     <m-denom>
                        {{var_Cr}}
                     </m-denom>
                     <m-raw>)</m-raw>
                     <m-rawcap> </m-rawcap>
                  </m-fraction>
                  &times;
                  {{var_Ca}}
               {{lu_math_vec_end}}
               =
               1
            </m-row>
            <m-row>
               <m-fraction>
                  <m-raw>(</m-raw>
                  <m-numer><!--
                     -->{{var_Hp}}
                        -
                        (<!--
                        -->({{var_Hp}} &bullet; {{var_Ca}}) - ({{var_Cb}} &bullet; {{var_Ca}})<!--
                     -->){{var_Ca}}
                        +
                        {{var_Cb}}<!--
                  --></m-numer>
                  <m-raw> &divide; </m-raw>
                  <m-denom>
                     {{var_Cr}}
                  </m-denom>
                  <m-raw>)</m-raw>
                  <m-rawcap> </m-rawcap>
               </m-fraction>
               &bullet;
               {{var_Ca}}
               =
               0
            </m-row>
         </m-content>
      </m-solvestep>
      <m-solvestep>
         {{lu_math_expl_start}}
            <p>
               For our cross product equation: given two vectors <lu-math data-inline><var data-type="vector">A</var></lu-math> and <lu-math data-inline><var data-type="vector">B</var></lu-math> and a scalar <lu-math data-inline><var>c</var></lu-math>:
            </p>
            <lu-math>
               <m-row>
                  <var>c</var><var data-type="vector">A</var> &times; <var data-type="vector">B</var>
                  =
                  <var data-type="vector">A</var> &times; <var>c</var><var data-type="vector">B</var>
                  =
                  (<var data-type="vector">A</var> &times; <var data-type="vector">B</var>)<var>c</var>
               </m-row>
            </lu-math>
            <p>
               As for the dot product equation:
            </p>
            <lu-math>
               <m-row>
                  <var>c</var>(<var data-type="vector">A</var> &bullet; <var data-type="vector">B</var>)
                  =
                  <var>c</var><var data-type="vector">A</var> &bullet; <var>c</var><var data-type="vector">B</var>
               </m-row>
            </lu-math>
            <p>
               Dividing by <lu-math data-inline><var>c</var></lu-math> is the same operation as multiplying by <lu-math data-inline>1 &divide; <var>c</var></lu-math>, which means that:
            </p>
            <lu-math>
               <m-row>
                  <m-fraction>
                     <m-raw>(</m-raw>
                     <m-numer><var>c</var><var data-type="vector">A</var> &bullet; <var data-type="vector">B</var></m-numer>
                     <m-raw>) &divide; </m-raw>
                     <m-denom><var>c</var></m-denom>
                  </m-fraction>
                  =
                  <var data-type="vector">A</var> &bullet;
                  <m-fraction>
                     <m-numer><var data-type="vector">B</var></m-numer>
                     <m-raw> &divide; </m-raw>
                     <m-denom><var>c</var></m-denom>
                  </m-fraction>
               </m-row>
            </lu-math>
         {{lu_math_expl_end}}
         <m-content>
            <m-row>
               {{lu_math_vec_start}}
                  <m-fraction>
                     <m-raw>(</m-raw>
                     <m-numer><!--
                     -->({{var_Hp}}
                        -
                        (<!--
                        -->({{var_Hp}} &bullet; {{var_Ca}}) - ({{var_Cb}} &bullet; {{var_Ca}})<!--
                     -->){{var_Ca}}
                        +
                        {{var_Cb}})
                        &times;
                        {{var_Ca}}<!--
                  --></m-numer>
                     <m-raw> &divide; </m-raw>
                     <m-denom>
                        {{var_Cr}}
                     </m-denom>
                     <m-raw>)</m-raw>
                     <m-rawcap> </m-rawcap>
                  </m-fraction>
               {{lu_math_vec_end}}
               =
               1
            </m-row>
            <m-row>
               <m-fraction>
                  <m-raw>(</m-raw>
                  <m-numer><!--
                     -->({{var_Hp}}
                        -
                        (<!--
                        -->({{var_Hp}} &bullet; {{var_Ca}}) - ({{var_Cb}} &bullet; {{var_Ca}})<!--
                     -->){{var_Ca}}
                        +
                        {{var_Cb}})
                        &bullet;
                        {{var_Ca}}{{var_Cr}}<!--
                  --></m-numer>
                  <m-raw> &divide; </m-raw>
                  <m-denom>
                     {{var_Cr}}
                  </m-denom>
                  <m-raw>)</m-raw>
                  <m-rawcap> </m-rawcap>
               </m-fraction>
               =
               0
            </m-row>
         </m-content>
      </m-solvestep>
      <m-solvestep>
         {{lu_math_expl_start}}
            Cross product and dot product operations are both distributive over addition.
         {{lu_math_expl_end}}
         <m-content>
            <m-row>
               {{lu_math_vec_start}}
                  <m-fraction>
                     <m-raw>(</m-raw>
                     <m-numer><!--
                     -->({{var_Hp}} &times; {{var_Ca}})
                        -
                        ((<!--
                        -->({{var_Hp}} &bullet; {{var_Ca}}) - ({{var_Cb}} &bullet; {{var_Ca}})<!--
                     -->){{var_Ca}} &times; {{var_Ca}})
                        +
                        ({{var_Cb}} &times; {{var_Ca}})<!--
                  --></m-numer>
                     <m-raw> &divide; </m-raw>
                     <m-denom>
                        {{var_Cr}}
                     </m-denom>
                     <m-raw>)</m-raw>
                     <m-rawcap> </m-rawcap>
                  </m-fraction>
               {{lu_math_vec_end}}
               =
               1
            </m-row>
            <m-row>
               <m-fraction>
                  <m-raw>(</m-raw>
                  <m-numer><!--
                     -->({{var_Hp}} &bullet; {{var_Ca}}{{var_Cr}})
                        -
                        (<!--
                        -->(<!--
                           -->({{var_Hp}} &bullet; {{var_Ca}}) - ({{var_Cb}} &bullet; {{var_Ca}})<!--
                        -->){{var_Ca}}
                           &bullet;
                           {{var_Ca}}{{var_Cr}}<!--
                     -->)
                        +
                        ({{var_Cb}} &bullet; {{var_Ca}}{{var_Cr}})<!--
                  --></m-numer>
                  <m-raw> &divide; </m-raw>
                  <m-denom>
                     {{var_Cr}}
                  </m-denom>
                  <m-raw>)</m-raw>
                  <m-rawcap> </m-rawcap>
               </m-fraction>
               =
               0
            </m-row>
         </m-content>
      </m-solvestep>
      <m-solvestep>
         <m-content>
            <m-row>
               {{lu_math_vec_start}}
                  ({{var_Hp}} &times; {{var_Ca}}){{var_Cr}}
                  -
                  ((<!--
                  -->({{var_Hp}} &bullet; {{var_Ca}}) - ({{var_Cb}} &bullet; {{var_Ca}})<!--
               -->){{var_Ca}} &times; {{var_Ca}}){{var_Cr}}
                  +
                  ({{var_Cb}} &times; {{var_Ca}}){{var_Cr}}
               {{lu_math_vec_end}}
               =
               {{var_Cr}}
            </m-row>
            <m-row>
               ({{var_Hp}} &bullet; {{var_Ca}}{{var_Cr}}){{var_Cr}}
               -
               (<!--
               -->(<!--
                  -->({{var_Hp}} &bullet; {{var_Ca}}) - ({{var_Cb}} &bullet; {{var_Ca}})<!--
               -->){{var_Ca}}
                  &bullet;
                  {{var_Ca}}{{var_Cr}}<!--
            -->){{var_Cr}}
               +
               ({{var_Cb}} &bullet; {{var_Ca}}{{var_Cr}}){{var_Cr}}
               =
               0
            </m-row>
         </m-content>
      </m-solvestep>
   </lu-math>
   <p>
      I think there's a big simplification we can make to the bottom equation:
   </p>
   <lu-math>
      <m-solvestep>
         {{lu_math_expl_start}}
            Remember that 
            <lu-math data-inline>
               <var>c</var><var data-type="vector">A</var> &bullet; <var data-type="vector">B</var>
               =
               <var>c</var>(<var data-type="vector">A</var> &bullet; <var data-type="vector">B</var>)<!--
         --></lu-math>. In this situation, the expression 
            <lu-math data-inline>
               (<!--
               -->({{var_Hp}} &bullet; {{var_Ca}}) - ({{var_Cb}} &bullet; {{var_Ca}})<!--
            -->)
            </lu-math>
            is our <lu-math data-inline><var>c</var></lu-math>.
         {{lu_math_expl_end}}
         <m-content>
            <m-row>
               {{lu_math_vec_start}}
                  ({{var_Hp}} &times; {{var_Ca}}){{var_Cr}}
                  -
                  ((<!--
                  -->({{var_Hp}} &bullet; {{var_Ca}}) - ({{var_Cb}} &bullet; {{var_Ca}})<!--
               -->){{var_Ca}} &times; {{var_Ca}}){{var_Cr}}
                  +
                  ({{var_Cb}} &times; {{var_Ca}}){{var_Cr}}
               {{lu_math_vec_end}}
               =
               {{var_Cr}}
            </m-row>
            <m-row>
               ({{var_Hp}} &bullet; {{var_Ca}}{{var_Cr}}){{var_Cr}}
               -
               (<!--
               -->(<!--
                  -->({{var_Hp}} &bullet; {{var_Ca}}) - ({{var_Cb}} &bullet; {{var_Ca}})<!--
               -->)<mark>(</mark>{{var_Ca}}
                  &bullet;
                  {{var_Ca}}<mark>)</mark>{{var_Cr}}<!--
            -->){{var_Cr}}
               +
               ({{var_Cb}} &bullet; {{var_Ca}}{{var_Cr}}){{var_Cr}}
               =
               0
            </m-row>
         </m-content>
      </m-solvestep>
      <m-solvestep>
         {{lu_math_expl_start}}
            {{var_Ca_inl}} is an axis vector, so its length is 1; therefore, <lu-math data-inline>{{var_Ca}} &bullet; {{var_Ca}}</lu-math> is also 1. Separately from that, we can also merge multiplications by {{var_Cr_inl}} to get <lu-math data-inline>{{var_Cr}}{{lu_math_sq}}</lu-math>.
         {{lu_math_expl_end}}
         <m-content>
            <m-row>
               {{lu_math_vec_start}}
                  ({{var_Hp}} &times; {{var_Ca}}){{var_Cr}}
                  -
                  ((<!--
                  -->({{var_Hp}} &bullet; {{var_Ca}}) - ({{var_Cb}} &bullet; {{var_Ca}})<!--
               -->){{var_Ca}} &times; {{var_Ca}}){{var_Cr}}
                  +
                  ({{var_Cb}} &times; {{var_Ca}}){{var_Cr}}
               {{lu_math_vec_end}}
               =
               {{var_Cr}}
            </m-row>
            <m-row>
               ({{var_Hp}} &bullet; {{var_Ca}}{{var_Cr}}{{lu_math_sq}})
               -
               (<!--
               -->({{var_Hp}} &bullet; {{var_Ca}}) - ({{var_Cb}} &bullet; {{var_Ca}})<!--
            -->)<del>({{var_Ca}}
               &bullet;
               {{var_Ca}})</del>{{var_Cr}}{{lu_math_sq}}
               +
               ({{var_Cb}} &bullet; {{var_Ca}}{{var_Cr}}{{lu_math_sq}})
               =
               0
            </m-row>
         </m-content>
      </m-solvestep>
   </lu-math>
   <!--
      If we keep going, the terms in the dot product equation will cancel themselves out and 
      we'll end up with zero on both sides... which makes sense, really.
   -->
</section>

<section>
   <h2><a name="solving">Solving for the ray</a></h2>
   <p>
      A ray is commonly defined in terms of a starting point, or <dfn>origin</dfn>, and a normalized direction vector. We can therefore define the hit position in terms of the same.
   </p>
   <lu-math>
      <m-givens>
         <label>Given:</label>
         <dl>
            <dt><var>R<sub>o</sub></var></dt>
            <m-sep> = </m-sep>
               <dd>the ray's origin</dd>
            <dt><var>R<sub>d</sub></var></dt>
            <m-sep> = </m-sep>
               <dd>the ray's direction</dd>
            <dt><var>H<sub>p</sub></var></dt>
            <m-sep> = </m-sep>
               <dd>the position at which the ray hits some surface</dd>
            <dt><var>H<sub>d</sub></var></dt>
            <m-sep> = </m-sep>
               <dd>the hit distance: the distance from the ray origin to the hit position</dd>
         </dl>
      </m-givens>
      <m-row>
         <var>H<sub>p</sub></var><!--
      -->&nbsp;=&nbsp;<!--
      --><var>R<sub>o</sub></var> + <var>R<sub>d</sub></var><var>H<sub>d</sub></var>
      </m-row>
   </lu-math>
   <p>
      We can substitute this equation into our cylinder equation above, and then attempt to solve for the hit distance {{var_Hd_inl}}:
   </p>
   <lu-math>
      <m-solvestep>
         <m-content>
            (<!--
            --><mark>(<var>R<sub>o</sub></var> + <var>R<sub>d</sub></var><var>H<sub>d</sub></var>)</mark>
               &bullet;
               <var>C<sub>a</sub></var><var>C<sub>r</sub></var><!--
         -->)
            -
            (<!--
            -->(<!--
               -->(<var>C<sub>a</sub></var> &bullet; <mark>(<var>R<sub>o</sub></var> + <var>R<sub>d</sub></var><var>H<sub>d</sub></var>)</mark>)
                  -
                  (<var>C<sub>a</sub></var> &bullet; <var>C<sub>b</sub></var>)<!--
            -->)<var>C<sub>a</sub></var>
               &bullet;
               <var>C<sub>a</sub></var><var>C<sub>r</sub></var><!--
         -->)
            -
            (<!--
            --><var>C<sub>b</sub></var>
               &bullet;
               <var>C<sub>a</sub></var><var>C<sub>r</sub></var><!--
         -->)
            = 0
         </m-content>
      </m-solvestep>
      <m-solvestep>
         <details class="explanation">
            <summary class="toggle-explanation">info</summary>
            <aside>
               We can distribute dot product operations over additions.
            </aside>
         </details>
         <m-content>
            <mark>(<var>C<sub>a</sub></var><var>C<sub>r</sub></var> &bullet; {{dont_eat_this_space}}</mark><var>R<sub>o</sub></var>)
            +
            <mark>(<var>C<sub>a</sub></var><var>C<sub>r</sub></var> &bullet; {{dont_eat_this_space}}</mark><var>R<sub>d</sub></var><var>H<sub>d</sub></var>)
            -
            (<!--
            -->(<!--
               --><mark>(<var>C<sub>a</sub></var><var>C<sub>r</sub></var> &bullet; {{dont_eat_this_space}}</mark><var>R<sub>o</sub></var>)
                  +
                  <mark>(<var>C<sub>a</sub></var><var>C<sub>r</sub></var> &bullet; {{dont_eat_this_space}}</mark><var>R<sub>d</sub></var><var>H<sub>d</sub></var>)
                  -
                  (<var>C<sub>a</sub></var> &bullet; <var>C<sub>b</sub></var>)<!--
            -->)<var>C<sub>a</sub></var>
               &bullet;
               <var>C<sub>a</sub></var><var>C<sub>r</sub></var><!--
         -->)
            -
            (<!--
            --><var>C<sub>b</sub></var>
               &bullet;
               <var>C<sub>a</sub></var><var>C<sub>r</sub></var><!--
         -->)
            = 0
         </m-content>
      </m-solvestep>
   </lu-math>
   
   <!-- CONTINUE FROM HERE -->
   
   <!--
      IF THIS DOESN'T WORK, TRY BACKING UP TO BEFORE WE STRIPPED OUT THE CROSS PRODUCT. 
      WE COULD ATTEMPT TO SUBSTITUTE THE RAY IN RIGHT AT THAT POINT, AND ONLY SIMPLIFY 
      THE CROSS PRODUCT OUT AFTERWARD.
   -->
</section>