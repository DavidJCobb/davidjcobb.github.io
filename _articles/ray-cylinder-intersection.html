---
title: Ray/cylinder intersections
tags:
 - 3D
 - geometry
 - intersection
 - math
 - raycasting
social_media:
   description: The math behind doing raycasts for 3D cylinder. Includes public-domain code.
extra_css_files:
 - lu-math2.css
   
---
{%- include lu-math/defines.html -%}

{%- comment -%}

   HTML's whitespace handling works well for prose documents, but falls apart completely when we are, in 
   essence, designing our own markup, as we have for lu-math. Sometimes, we need to be able to GUARANTEE 
   that a given space WON'T be collapsed, without making it a non-breaking space.
   
   One example: having a leading space inside of an inline-block element.  Leading whitespace'll usually 
   be collapsed (y'know, except when it isn't), so using  this variable will slip a dummy element before 
   it so that it's not "leading" anymore.
   
{%- endcomment -%}
{%- assign dont_eat_this_space = "<span></span>" -%}
{%- assign print_one_space = "<span></span>&#32;" -%}

{%- assign lu_math_exps = "" | split: "," -%}
{%- for i in (0..5) -%}
   {%- capture temporary -%}
      <m-exp><span aria-hidden="true"><m-raw>^</m-raw>{{ i }}</span><m-raw data-screen-reader-only>&nbsp;
         {%- case i %}
            {%- when "0", 0 -%}
               to the zeroth power
            {%- when "1", 1 -%}
               to the first power
            {%- when "2", 2 -%}
               squared
            {%- when "3", 3 -%}
               cubed
            {%- else -%}
               to the {{i}}th power
         {%- endcase -%}&nbsp;</m-raw></m-exp>
   {%- endcapture -%}
   {%- assign temporary = temporary | append: "NEVEROCCURRINGSTRING" | split: "NEVEROCCURRINGSTRING" | slice: 0, 1 -%}
   {%- assign lu_math_exps = lu_math_exps | concat: temporary -%}
{%- endfor -%}
{%- assign lu_math_sq = lu_math_exps[2] -%}

{%- comment -%}
   
   Generate convenience variables for lu-math equation numbers. To display equation number 5, for example:
   {{lu_math_eq_numbers[5]}}
   
{%- endcomment -%}
{%- assign lu_math_eq_numbers = "" -%}
{%- for i in (1..20) -%}
   {%- capture temporary -%}
      <m-equation-number>
         <m-rawcap> </m-rawcap>
         <m-raw>[Equation </m-raw><m-value>{{i}}</m-value><m-raw>:]</m-raw>
         <m-rawcap> </m-rawcap>
      </m-equation-number>
   {%- endcapture -%}
   {%- assign temporary = temporary | prepend: "SPLITTER" -%}
   {%- assign lu_math_eq_numbers = lu_math_eq_numbers | append: temporary -%}
{%- endfor -%}
{%- assign lu_math_eq_numbers = lu_math_eq_numbers | split: "SPLITTER" -%}

{%- comment -%}
   
   Generate convenience variables for vector-length start and end tags. It is imperative that no whitespace 
   be present in these variables.
   
{%- endcomment -%}
{%- capture temporary -%}
   <m-veclength>
      <m-delim>||</m-delim>
      <m-content>%CONTENT%</m-content>
      <m-delim>||</m-delim>
   </m-veclength>
{%- endcapture -%}
{%- assign temporary  = temporary | strip_newlines | strip | split: " " -%}
{%- assign temporary2 = "" -%}
{%- assign temporary3 = false -%} {%- comment -%} In tag? {%- endcomment -%}
{%- assign temporary4 = false -%}
{%-comment-%}
   Comments so Notepad++'s syntax highlighter doesn't choke.
   <!--
{%-endcomment-%}
{%- for item in temporary -%}
   {%- assign temporary2 = temporary2 | append: item -%}
{%- endfor -%}
{%-comment-%}
   -->
   End of syntax highlighter comment.
{%-endcomment-%}
{%- assign temporary = temporary2 | split: "%CONTENT%" -%}
{%- assign lu_math_vec_start = temporary[0] -%}
{%- assign lu_math_vec_end = temporary[1] -%}

{%- capture lu_math_therefore_block -%}
   <m-therefore data-block>
      <span aria-hidden="true" title="therefore">&therefore;</span>
      <m-raw data-screen-reader-only>&therefore;</m-raw>
   </m-therefore>
{%- endcapture -%}

{%- assign math_inl_enter = "<lu-math data-inline>" -%}
{%- assign math_inl_leave = "</lu-math>" -%}
{%- assign var_Ca_inl = "<var>C<sub>a</sub></var>" | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Cb_inl = "<var>C<sub>b</sub></var>" | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Cr_inl = "<var>C<sub>r</sub></var>" | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Cs_inl = "<var>C<sub>s</sub></var>" | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Hd_inl = "<var>H<sub>d</sub></var>" | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Hn_inl = "<var>H<sub>n</sub></var>" | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Hp_inl = "<var>H<sub>p</sub></var>" | prepend: math_inl_enter | append: math_inl_leave -%}
{%- assign var_Hs_inl = "<var>H<sub>s</sub></var>" | prepend: math_inl_enter | append: math_inl_leave -%}
<section>
   <p>
      There are a lot of people out on the web who are willing to share raycasting code, 
      but not a whole lot of them bother to actually apply a permissive license to it so 
      that people can legally use it. What's more, a lot of them don't explain how they 
      actually derived the math involved either.
   </p>
   <p>
      Here, I'm going to walk through how to put together a ray/cylinder intersection test. 
      I've also provided code at the bottom as a public domain work.
   </p>
</section>

<section>
   <h2><a name="parametric"></a>Parametric surface of a cylinder</h2>
   <p>
      The parametric equations (that is, equations with parameters) for a cylinder are as follows:
   </p>
   <lu-math>
      <m-givens>
         <label>Given:</label>
         <dl>
            <dt><var>C<sub>h</sub></var></dt>
            <m-sep> = </m-sep>
               <dd>height of the cylinder</dd>
            <dt><var>C<sub>r</sub></var></dt>
            <m-sep> = </m-sep>
               <dd>radius of the cylinder</dd>
            <dt><var>H<sub>o</sub></var></dt>
            <m-sep> = </m-sep>
               <dd>height offset on the range [0, <var>C<sub>h</sub></var>], where 0 is aligned with an endcap</dd>
            <dt><var>&theta;</var></dt>
            <m-sep> = </m-sep>
               <dd>any angle, basically</dd>
         </dl>
      </m-givens>
      <m-layout-left>
         {{lu_math_eq_numbers[1]}}
         <m-row>
            <m-function-def>
               <m-name>f<sub>x</sub></m-name><!--
            --><m-args><!--
               --><m-delim>(</m-delim>
                     <m-arg><var>H<sub>o</sub></var></m-arg>
                  <m-sep>, </m-sep>
                     <m-arg><var>&theta;</var></m-arg>
                  <m-delim>)</m-delim><!--
            --></m-args>
            </m-function-def>
            =
            <var>C<sub>r</sub></var> &times; cos(<var>&theta;</var>)
         </m-row>
         <m-row>
            <m-function-def>
               <m-name>f<sub>y</sub></m-name><!--
            --><m-args><!--
               --><m-delim>(</m-delim>
                     <m-arg><var>H<sub>o</sub></var></m-arg>
                  <m-sep>, </m-sep>
                     <m-arg><var>&theta;</var></m-arg>
                  <m-delim>)</m-delim><!--
            --></m-args>
            </m-function-def>
            =
            <var>C<sub>r</sub></var> &times; sin(<var>&theta;</var>)
         </m-row>
         <m-row>
            <m-function-def>
               <m-name>f<sub>z</sub></m-name><!--
            --><m-args><!--
               --><m-delim>(</m-delim>
                     <m-arg><var>H<sub>o</sub></var></m-arg>
                  <m-sep>, </m-sep>
                     <m-arg><var>&theta;</var></m-arg>
                  <m-delim>)</m-delim><!--
            --></m-args>
            </m-function-def>
            =
            <var>H<sub>o</sub></var>
         </m-row>
      </m-layout-left>
   </lu-math>
   <p>
      Technically, these equations describe an infinite cylinder &mdash; one with no endcaps, which extends forever in both directions. However, we can still use them to put together the tests for a finite clinder with endcaps.
   </p>
   <p>
      You may notice that these are very similar to the parametric equations <a href="{% link _articles/ray-cone-intersection.html %}">for a cone</a>. Mathematically speaking, a cylinder is basically a cone with infinite height, and geometrically speaking, a cylinder is just a cone that never tapers. Moreover, if we ignore the Z-component, then we're literally just writing the equation for a 2D circle.
   </p>
</section>

<section>
   <h2><a name="implicit">Implicit surface of a cylinder</a></h2>
   <p>
      We have a <dfn>parametric surface</dfn> &mdash; that is, three parametric equations which define all points on the surface of the cylinder. In order to solve for any given part of the equation, however, we need an <dfn>implicit surface</dfn>: a surface defined by a single equation, wherein <lu-math data-inline><var>x</var></lu-math>, <lu-math data-inline><var>y</var></lu-math>, and <lu-math data-inline><var>z</var></lu-math> are on one side, and 0 is on the other side.
   </p>
   <p>
      The above equations basically define a 2D circle anchored at <lu-math data-inline>(0, 0)</lu-math> on the XY-plane, and then extend it infinitely along the Z-axis. The circle's radius is {{var_Cr_inl}}. This means that we can represent the X and Y equations in terms of any arbitrary 2D vector <lu-math data-inline><var>P<sub>2D</sub></var></lu-math>:
   </p>
   <lu-math>
      {{lu_math_eq_numbers[2]}}
      
      <m-veclength>
         <m-delim>||</m-delim><!--
      --><var>P<sub>2D</sub></var><!--
      --><m-delim>||</m-delim>
      </m-veclength>
      =
      <var>C<sub>r</sub></var>
   </lu-math>
   <p>
      If we project a 3D vector <lu-math data-inline><var>P</var></lu-math> onto the Z-axis, then we'll have just its Z-component. Remove that component, and we can then fit it into the equation above.
   </p>
   <lu-math>
      <m-givens>
         <label>Given:</label>
         <dl>
            <dt><var>P</var></dt>
            <m-sep> = </m-sep>
               <dd>any point on the curved surface of the infinite cylinder</dd>
            <dt><var>C<sub>a</sub></var></dt>
            <m-sep> = </m-sep>
               <dd>axis of the cylinder; in this case, (0, 0, 1)</dd>
            <dt><var>P<sub>s</sub></var></dt>
            <m-sep> = </m-sep>
               <dd><var>P</var> projected onto <var>C<sub>a</sub></var></dd>
         </dl>
      </m-givens>
      <m-row>
         <var>P<sub>s</sub></var>
          = 
         (<var>P</var> &bullet; <var>C<sub>a</sub></var>)
          &times;
         <var>C<sub>a</sub></var>
      </m-row>
      <m-row>
         {{lu_math_eq_numbers[3]}}
         
         <m-veclength>
            <m-delim>||</m-delim><!--
         --><var>P</var> - <var>P<sub>s</sub></var><!--
         --><m-delim>||</m-delim>
         </m-veclength>
         =
         <var>C<sub>r</sub></var>
      </m-row>
   </lu-math>
   <p>
      If we so desire, we can now subtract {{var_Cr_inl}} from both sides of the equation in order to have one side contain only zero. As such, this is now an implicit surface, which defines a cylinder that has one endcap centered on <lu-math data-inline>(0, 0, 0)</lu-math>.
   </p>
</section>

<section>
   <h2><a name="transformed">Handling a translated and rotated cylinder</a></h2>
   <p>
      In general, we'll want to run raycasts against a bounded cylinder &mdash; one with endcaps, rather than one that extends infinitely along its axis. There's no equation that can represent a bounded cylinder directly. However, we can still represent an infinite cylinder in terms of where the endcaps <em>would</em> be, and then use some distance checks later to enforce bounds.
   </p>
   <p>
      Let's take the implicit surface of an infinite cylinder, and represent it in terms of the endcaps.
   </p>
   <lu-math>
      <m-givens>
         <label>Given:</label>
         <dl>
            <dt><var>C<sub>b</sub></var></dt>
            <m-sep> = </m-sep>
               <dd>centerpoint of the cylinder's bottom endcap</dd>
            <dt><var>C<sub>t</sub></var></dt>
            <m-sep> = </m-sep>
               <dd>centerpoint of the cylinder's top endcap</dd>
            <dt><var>C<sub>s</sub></var></dt>
            <m-sep> = </m-sep>
               <dd>"spine" of the cylinder: a vector from the top to the bottom, equal to <var>C<sub>t</sub></var> - <var>C<sub>b</sub></var></dd>
            <dt><var>C<sub>a</sub></var></dt>
            <m-sep> = </m-sep>
               <dd>axis of the cylinder: normalized spine</dd>
            <dt><var>H<sub>p</sub></var></dt>
            <m-sep> = </m-sep>
               <dd>hit position: a point that we presume is on the cylinder's curved surface</dd>
            <dt><var>H<sub>s</sub></var></dt>
            <m-sep> = </m-sep>
               <dd>hit spine position: the hit position projected onto <var>C<sub>s</sub></var>; this position = ((<var>H<sub>p</sub></var> - <var>C<sub>b</sub></var>) &bullet; <var>C<sub>a</sub></var>)<var>C<sub>a</sub></var> + <var>C<sub>b</sub></var></dd>
            <dt><var>H<sub>o</sub></var></dt>
            <m-sep> = </m-sep>
               <dd>the height offset from our cylinder equations; this is the distance from <var>H<sub>s</sub></var> to <var>C<sub>b</sub></var> i.e. ||<var>H<sub>s</sub></var> - <var>C<sub>b</sub></var>||.</dd>
         </dl>
      </m-givens>
   </lu-math>
   <p>
      {{var_Hp_inl}} fills the role of <lu-math data-inline><var>P</var></lu-math> in Equation 3, and {{var_Hs_inl}} fills the role of <lu-math data-inline><var>P<sub>p</sub></var></lu-math>. {{var_Hs_inl}} is the hit position projected onto the cylinder's axis &mdash; its "spine." If we view the cylinder from its endcap, then {{var_Hs_inl}} will be at the center of a circle; if {{var_Hp_inl}} is indeed on the cylinder's curved surface, then the distance from it to {{var_Hs_inl}} will equal the cylinder's radius:
   </p>
   <lu-math>
      {{lu_math_eq_numbers[4]}}
      
      <m-row>
         {{lu_math_vec_start}}<var>H<sub>p</sub></var> - <var>H<sub>s</sub></var>{{lu_math_vec_end}}
         =
         <var>C<sub>r</sub></var>
      </m-row>
   </lu-math>
   <p>
      We could try expanding {{var_Hs_inl}} and getting a more complete equation &mdash; something we could plug the equation for our ray into &mdash; but I've actually tried that, and, uh,... it doesn't work so well. We <em>get</em> an equation that we <em>could</em> technically use, but it's huge and inefficient. So instead, let's look at the geometry of the problem and see if we can make any deductions that might help.
   </p>
   <p>
      If the hit position is on the surface, then the vector from {{var_Hs_inl}} to {{var_Hp_inl}} will have the same length as the cylinder's radius. What's more: it will be perpendicular to the cylinder's axis {{var_Ca_inl}}, and parallel to the surface normal vector at the hit position. If we normalize this vector, we <em>get</em> the surface normal. We can add that to our equations: if two vectors are perpendicular, then their cross product will have length 1.
   </p>
   <lu-math>
      <m-givens>
         <label>Given:</label>
         <dl>
            <dt><var>H<sub>n</sub></var></dt>
            <m-sep> = </m-sep>
               <dd>
                  <span>
                     the surface normal at the hit position =
                  </span>
                  <m-fraction>
                     <m-raw>(</m-raw>
                     <m-numer><var>H<sub>p</sub></var> - <var>H<sub>s</sub></var></m-numer>
                     <m-raw> &divide; </m-raw>
                     <m-denom>
                        {{lu_math_vec_start}}<var>H<sub>p</sub></var> - <var>H<sub>s</sub></var>{{lu_math_vec_end}}
                     </m-denom>
                     <m-raw>)</m-raw>
                     <m-rawcap> </m-rawcap>
                  </m-fraction>
               </dd>
         </dl>
      </m-givens>
      <m-row>
         {{lu_math_vec_start}}<var>H<sub>p</sub></var> - <var>H<sub>s</sub></var>{{lu_math_vec_end}}
         =
         <var>C<sub>r</sub></var>
      </m-row>
      <m-row>
         <span>
            <var>H<sub>n</sub></var>
            =
         </span>
         <m-fraction>
            <m-raw>(</m-raw>
            <m-numer><var>H<sub>p</sub></var> - <var>H<sub>s</sub></var></m-numer>
            <m-raw> &divide; </m-raw>
            <m-denom>
               {{lu_math_vec_start}}<var>H<sub>p</sub></var> - <var>H<sub>s</sub></var>{{lu_math_vec_end}}
            </m-denom>
            <m-raw>)</m-raw>
            <m-rawcap> </m-rawcap>
         </m-fraction>
         <span>
            =
         </span>
         <m-fraction>
            <m-raw>(</m-raw>
            <m-numer><var>H<sub>p</sub></var> - <var>H<sub>s</sub></var></m-numer>
            <m-raw> &divide; </m-raw>
            <m-denom>
               <var>C<sub>r</sub></var>
            </m-denom>
            <m-raw>)</m-raw>
            <m-rawcap> </m-rawcap>
         </m-fraction>
      </m-row>
      <m-row>
         {{lu_math_eq_numbers[5]}}
         
         {{lu_math_vec_start}}<var>H<sub>n</sub></var> &times; <var>C<sub>a</sub></var>{{lu_math_vec_end}}
         =
         1
      </m-row>
   </lu-math>
   <p>
      It seems that the thing to do, at this point, is try and solve for a ray/cylinder intersection based on the surface normal at the hit position. Let's start by expanding {{var_Hn_inl}} within Equation 5.
   </p>
   <lu-math>
      <m-solvestep>
         <m-content>
            <m-rawcap> </m-rawcap>
            {{lu_math_vec_start}}<!--
            --><m-fraction>
                  <m-raw>(</m-raw>
                  <m-numer><var>H<sub>p</sub></var> - <var>H<sub>s</sub></var></m-numer>
                  <m-raw>) &divide; </m-raw>
                  <m-denom>
                     <var>C<sub>r</sub></var>
                  </m-denom>
                  <m-rawcap> </m-rawcap>
               </m-fraction>
               &times;
               <var>C<sub>a</sub></var><!--
         -->{{lu_math_vec_end}}
            =
            1
         </m-content>
      </m-solvestep>
      <m-solvestep>
         <details class="explanation">
            <summary class="toggle-explanation">info</summary>
            <aside>
               If you take the dot product of a vector with itself, then you get the vector's length squared. This means that we can square both sides of the equation, and convert the squared length on the lefthand side to a dot product of the contents with themselves. Of course, 1 squared is just 1 again, so in practice, we don't see an exponent on either side.
            </aside>
         </details>
         <m-content>
            <m-rawcap> </m-rawcap>
            (<!--
            --><m-fraction>
                  <m-raw>(</m-raw>
                  <m-numer><var>H<sub>p</sub></var> - <var>H<sub>s</sub></var></m-numer>
                  <m-raw>) &divide; </m-raw>
                  <m-denom>
                     <var>C<sub>r</sub></var>
                  </m-denom>
                  <m-rawcap> </m-rawcap>
               </m-fraction>
               &times;
               <var>C<sub>a</sub></var><!--
         -->)<mark>{{dont_eat_this_space}} &bullet; (<!--
            --><m-fraction>
                  <m-raw>(</m-raw>
                  <m-numer><var>H<sub>p</sub></var> - <var>H<sub>s</sub></var></m-numer>
                  <m-raw>) &divide; </m-raw>
                  <m-denom>
                     <var>C<sub>r</sub></var>
                  </m-denom>
                  <m-rawcap> </m-rawcap>
               </m-fraction>
               &times;
               <var>C<sub>a</sub></var><!--
         -->)</mark>
            =
            1
         </m-content>
      </m-solvestep>
   </lu-math>
   <p>
      Let's look at some known identities involving vector algebra, and see if we can rearrange that further.
   </p>
   <lu-math>
      <m-solvestep>
         <details class="explanation">
            <summary class="toggle-explanation">info</summary>
            <aside>
               This is the <dfn>Binet-Cauchy identity</dfn>.
            </aside>
         </details>
         <m-content>
            (<var>A</var> &times; <var>B</var>) &bullet; (<var>C</var> &times; <var>D</var>)
            =
            (<var>A</var> &bullet; <var>C</var>)(<var>B</var> &bullet; <var>D</var>)
            -
            (<var>B</var> &bullet; <var>C</var>)(<var>A</var> &bullet; <var>D</var>)
         </m-content>
      </m-solvestep>
      {{lu_math_therefore_block}}
      <m-solvestep>
         <m-content>
            <m-big-parens><!--
            --><m-delim>(</m-delim><!--
            --><m-content><!--
               
            --><m-fraction>
                  <m-raw>(</m-raw>
                  <m-numer><var>H<sub>p</sub></var> - <var>H<sub>s</sub></var></m-numer>
                  <m-raw>) &divide; </m-raw>
                  <m-denom>
                     <var>C<sub>r</sub></var>
                  </m-denom>
                  <m-rawcap> </m-rawcap>
               </m-fraction>
               &bullet;
               <m-fraction>
                  <m-raw>(</m-raw>
                  <m-numer><var>H<sub>p</sub></var> - <var>H<sub>s</sub></var></m-numer>
                  <m-raw>) &divide; </m-raw>
                  <m-denom>
                     <var>C<sub>r</sub></var>
                  </m-denom>
                  <m-rawcap> </m-rawcap>
               </m-fraction><!--
               
            --></m-content><!--
            --><m-delim>)</m-delim><!--
         --></m-big-parens><!--
         -->(<!--
            --><var>C<sub>a</sub></var>
               &bullet;
               <var>C<sub>a</sub></var><!--
         -->)
            -
            <m-big-parens><!--
            --><m-delim>(</m-delim><!--
            --><m-content><!--
               
            --><m-fraction>
                  <m-raw>(</m-raw>
                  <m-numer><var>H<sub>p</sub></var> - <var>H<sub>s</sub></var></m-numer>
                  <m-raw>) &divide; </m-raw>
                  <m-denom>
                     <var>C<sub>r</sub></var>
                  </m-denom>
                  <m-rawcap> </m-rawcap>
               </m-fraction>
               &bullet;
               <var>C<sub>a</sub></var><!--
               
            --></m-content><!--
            --><m-delim>)</m-delim><!--
         --></m-big-parens><!--
         --><m-big-parens><!--
            --><m-delim>(</m-delim><!--
            --><m-content><!--
               
            --><m-fraction>
                  <m-raw>(</m-raw>
                  <m-numer><var>H<sub>p</sub></var> - <var>H<sub>s</sub></var></m-numer>
                  <m-raw>) &divide; </m-raw>
                  <m-denom>
                     <var>C<sub>r</sub></var>
                  </m-denom>
                  <m-rawcap> </m-rawcap>
               </m-fraction>
               &bullet;
               <var>C<sub>a</sub></var><!--
               
            --></m-content><!--
            --><m-delim>)</m-delim><!--
         --></m-big-parens>
            <span>
               = 1
            </span>
         </m-content>
      </m-solvestep>
      <m-solvestep>
         <details class="explanation">
            <summary class="toggle-explanation">info</summary>
            <aside>
               Removed a multiplication by <lu-math data-inline><var>C<sub>a</sub></var> &bullet; <var>C<sub>a</sub></var></lu-math>. That vector has length 1, so that dot product just produces 1.
            </aside>
         </details>
         <m-content>
            <m-big-parens><!--
            --><m-delim>(</m-delim><!--
            --><m-content><!--
               
            --><m-fraction>
                  <m-raw>(</m-raw>
                  <m-numer><var>H<sub>p</sub></var> - <var>H<sub>s</sub></var></m-numer>
                  <m-raw>) &divide; </m-raw>
                  <m-denom>
                     <var>C<sub>r</sub></var>
                  </m-denom>
                  <m-rawcap> </m-rawcap>
               </m-fraction>
               &bullet;
               <m-fraction>
                  <m-raw>(</m-raw>
                  <m-numer><var>H<sub>p</sub></var> - <var>H<sub>s</sub></var></m-numer>
                  <m-raw>) &divide; </m-raw>
                  <m-denom>
                     <var>C<sub>r</sub></var>
                  </m-denom>
                  <m-rawcap> </m-rawcap>
               </m-fraction><!--
               
            --></m-content><!--
            --><m-delim>)</m-delim><!--
         --></m-big-parens><!--
         --><del>(<!--
            --><var>C<sub>a</sub></var>
               &bullet;
               <var>C<sub>a</sub></var><!--
         -->)</del>
            -
            <m-big-parens><!--
            --><m-delim>(</m-delim><!--
            --><m-content><!--
               
            --><m-fraction>
                  <m-raw>(</m-raw>
                  <m-numer><var>H<sub>p</sub></var> - <var>H<sub>s</sub></var></m-numer>
                  <m-raw>) &divide; </m-raw>
                  <m-denom>
                     <var>C<sub>r</sub></var>
                  </m-denom>
                  <m-rawcap> </m-rawcap>
               </m-fraction>
               &bullet;
               <var>C<sub>a</sub></var><!--
               
            --></m-content><!--
            --><m-delim>)</m-delim><!--
         --></m-big-parens><!--
         --><m-big-parens><!--
            --><m-delim>(</m-delim><!--
            --><m-content><!--
               
            --><m-fraction>
                  <m-raw>(</m-raw>
                  <m-numer><var>H<sub>p</sub></var> - <var>H<sub>s</sub></var></m-numer>
                  <m-raw>) &divide; </m-raw>
                  <m-denom>
                     <var>C<sub>r</sub></var>
                  </m-denom>
                  <m-rawcap> </m-rawcap>
               </m-fraction>
               &bullet;
               <var>C<sub>a</sub></var><!--
               
            --></m-content><!--
            --><m-delim>)</m-delim><!--
         --></m-big-parens>
            <span>
               = 1
            </span>
         </m-content>
      </m-solvestep>
      <m-solvestep>
         <details class="explanation">
            <summary class="toggle-explanation">info</summary>
            <aside>
               Those terms on the left are the hit normal {{var_Hn_inl}}, remember? That vector's length is also 1, so we can remove the other lefthand dot product as well.
            </aside>
         </details>
         <m-content>
            <mark>1</mark><!--
         --><del class="invis"><m-big-parens class="del"><!--
            --><m-delim>(</m-delim><!--
            --><m-content><!--
                  
               --><m-fraction>
                     <m-raw>(</m-raw>
                     <m-numer><var>H<sub>p</sub></var> - <var>H<sub>s</sub></var></m-numer>
                     <m-raw>) &divide; </m-raw>
                     <m-denom>
                        <var>C<sub>r</sub></var>
                     </m-denom>
                     <m-rawcap> </m-rawcap>
                  </m-fraction>
                  &bullet;
                  <m-fraction>
                     <m-raw>(</m-raw>
                     <m-numer><var>H<sub>p</sub></var> - <var>H<sub>s</sub></var></m-numer>
                     <m-raw>) &divide; </m-raw>
                     <m-denom>
                        <var>C<sub>r</sub></var>
                     </m-denom>
                     <m-rawcap> </m-rawcap>
                  </m-fraction><!--
                  
            --></m-content><!--
            --><m-delim>)</m-delim><!--
         --></m-big-parens></del>
            -
            <m-big-parens><!--
            --><m-delim>(</m-delim><!--
            --><m-content><!--
               
            --><m-fraction>
                  <m-raw>(</m-raw>
                  <m-numer><var>H<sub>p</sub></var> - <var>H<sub>s</sub></var></m-numer>
                  <m-raw>) &divide; </m-raw>
                  <m-denom>
                     <var>C<sub>r</sub></var>
                  </m-denom>
                  <m-rawcap> </m-rawcap>
               </m-fraction>
               &bullet;
               <var>C<sub>a</sub></var><!--
               
            --></m-content><!--
            --><m-delim>)</m-delim><!--
         --></m-big-parens><!--
         --><m-big-parens><!--
            --><m-delim>(</m-delim><!--
            --><m-content><!--
               
            --><m-fraction>
                  <m-raw>(</m-raw>
                  <m-numer><var>H<sub>p</sub></var> - <var>H<sub>s</sub></var></m-numer>
                  <m-raw>) &divide; </m-raw>
                  <m-denom>
                     <var>C<sub>r</sub></var>
                  </m-denom>
                  <m-rawcap> </m-rawcap>
               </m-fraction>
               &bullet;
               <var>C<sub>a</sub></var><!--
               
            --></m-content><!--
            --><m-delim>)</m-delim><!--
         --></m-big-parens>
            <span>
               = 1
            </span>
         </m-content>
      </m-solvestep>
      <m-solvestep>
         <details class="explanation">
            <summary class="toggle-explanation">info</summary>
            <aside>
               <p>
                  The vector dot product is associative, but for scalars only. What this means is that for two vectors, <lu-math data-inline><var>A</var></lu-math> and <lu-math data-inline><var>B</var></lu-math>, and a scalar <nobr><lu-math data-inline><var>c</var></lu-math>,</nobr> the expression <lu-math data-inline>(<var>A</var> &bullet; <nobr><var>B</var>)<var>c</var></nobr></lu-math> is equal to <lu-math data-inline><var>A</var><var>c</var> &bullet; <var>B</var><var>c</var></lu-math>. We're converting between these two forms, but in reverse. Only one of our vectors is divided, but that's not a problem:
               </p>
               <lu-math>
                  <m-row>
                     <span>
                        <var>A</var>
                        &bullet;
                        <var>B</var><var>c</var>
                        = 
                     </span>
                     <m-big-parens><!--
                     --><m-delim>(</m-delim><!--
                     --><m-content><!--
                        
                        --><m-raw>(</m-raw><!--
                        --><m-fraction>
                              <m-numer><var>A</var></m-numer>
                              <m-raw> &divide; </m-raw>
                              <m-denom><var>c</var></m-denom>
                           </m-fraction><!--
                        --><m-raw>)</m-raw>
                           &bullet;
                           <var>B</var><!--
               
                     --></m-content><!--
                     --><m-delim>)</m-delim><!--
                  --></m-big-parens><!--
                  --><var>c</var>
                  </m-row>
               </lu-math>
               <p>
                  Division by <lu-math data-inline><var>c</var></lu-math> is, of course, just multiplication by <lu-math data-inline>1 &divide; <var>c</var></lu-math>, so we can apply this rule to unpack divisions within the dot product as well:
               </p>
               <lu-math>
                  <m-row>
                     <var>A</var>
                     &bullet;
                     <m-fraction>
                        <m-numer><var>B</var></m-numer>
                        <m-raw> &divide; </m-raw>
                        <m-denom><var>c</var></m-denom>
                     </m-fraction><!--
                  --><m-raw>)</m-raw>
                     =
                     <m-fraction>
                        <m-numer>
                           <var>A</var><var>c</var> &bullet; <var>B</var>
                        </m-numer>
                        <m-raw> &divide; </m-raw>
                        <m-denom><var>c</var></m-denom>
                     </m-fraction>
                  </m-row>
               </lu-math>
            </aside>
         </details>
         <m-content>
            1
            &minus;
            <m-big-parens><!--
            --><m-delim>(</m-delim><!--
            --><m-content><!--
               
            --><m-fraction>
                  <m-raw>(</m-raw>
                  <m-numer><!--
                  -->(<var>H<sub>p</sub></var> - <var>H<sub>s</sub></var>)
                     &bullet;
                     <var>C<sub>a</sub></var><var>C<sub>r</sub></var><!--
               --></m-numer>
                  <m-raw>) &divide; </m-raw>
                  <m-denom>
                     <var>C<sub>r</sub></var>
                  </m-denom>
               </m-fraction><!--
               
            --></m-content><!--
            --><m-delim>)</m-delim><!--
         --></m-big-parens><!--
         --><m-big-parens><!--
            --><m-delim>(</m-delim><!--
            --><m-content><!--
               
            --><m-fraction>
                  <m-raw>(</m-raw>
                  <m-numer><!--
                  -->(<var>H<sub>p</sub></var> - <var>H<sub>s</sub></var>)
                     &bullet;
                     <var>C<sub>a</sub></var><var>C<sub>r</sub></var><!--
               --></m-numer>
                  <m-raw>) &divide; </m-raw>
                  <m-denom>
                     <var>C<sub>r</sub></var>
                  </m-denom>
               </m-fraction><!--
               
            --></m-content><!--
            --><m-delim>)</m-delim><!--
         --></m-big-parens>
            <span>
               = 1
            </span>
         </m-content>
      </m-solvestep>
      <m-solvestep>
         <details class="explanation">
            <summary class="toggle-explanation">info</summary>
            <aside>
               When you multiply two fractions together, the inverse (<lu-math data-inline>1 &divide; <var>x</var></lu-math>) of their denominator acts like a common factor. You can group both of the fractions together &mdash; numerator 1 times numerator 2, all divided by denominator 1 times denominator 2.
            </aside>
         </details>
         <m-content>
            1
            &minus;
            <m-fraction>
               <m-raw>(</m-raw>
               <m-numer><!--
               -->(<!--
                  -->((<var>H<sub>p</sub></var> - <var>H<sub>s</sub></var>)
                     &bullet;
                     <var>C<sub>a</sub></var><var>C<sub>r</sub></var><!--
               -->)<!--
               -->(<!--
                  -->(<var>H<sub>p</sub></var> - <var>H<sub>s</sub></var>)
                     &bullet;
                     <var>C<sub>a</sub></var><var>C<sub>r</sub></var><!--
               -->)<!--
            --></m-numer>
               <m-raw>) &divide; </m-raw>
               <m-denom>
                  <var>C<sub>r</sub></var>{{lu_math_sq}}
               </m-denom>
            </m-fraction>
            <span>
               = 1
            </span>
         </m-content>
      </m-solvestep>
      <m-solvestep>
         <details class="explanation">
            <summary class="toggle-explanation">info</summary>
            <aside>
               Multiplfying both sides by the denominator, to get us out of that fraction.
            </aside>
         </details>
         <m-content>
            <var>C<sub>r</sub></var>{{lu_math_sq}}
            -
            (<!--
            -->((<var>H<sub>p</sub></var> - <var>H<sub>s</sub></var>)
               &bullet;
               <var>C<sub>a</sub></var><var>C<sub>r</sub></var><!--
         -->)<!--
         -->(<!--
            -->(<var>H<sub>p</sub></var> - <var>H<sub>s</sub></var>)
               &bullet;
               <var>C<sub>a</sub></var><var>C<sub>r</sub></var><!--
         -->)
            = <var>C<sub>r</sub></var>{{lu_math_sq}}
         </m-content>
      </m-solvestep>
      <m-solvestep>
         <details class="explanation">
            <summary class="toggle-explanation">info</summary>
            <aside>
               Square root of both sides.
            </aside>
         </details>
         <m-content>
            <var>C<sub>r</sub></var><del>{{lu_math_sq}}</del>
            -
            (<!--
            -->((<var>H<sub>p</sub></var> - <var>H<sub>s</sub></var>)
               &bullet;
               <var>C<sub>a</sub></var><var>C<sub>r</sub></var><!--
         -->)<!--
         --><del>(<!--
            -->(<var>H<sub>p</sub></var> - <var>H<sub>s</sub></var>)
               &bullet;
               <var>C<sub>a</sub></var><var>C<sub>r</sub></var><!--
         -->)</del>
            = <var>C<sub>r</sub></var><del>{{lu_math_sq}}</del>
         </m-content>
      </m-solvestep>
      <m-solvestep>
         <m-content>
            -<!--
         -->(<!--
            -->((<var>H<sub>p</sub></var> - <var>H<sub>s</sub></var>)
               &bullet;
               <var>C<sub>a</sub></var><var>C<sub>r</sub></var><!--
         -->)
            = 0
         </m-content>
      </m-solvestep>
      <m-solvestep>
         <details class="explanation">
            <summary class="toggle-explanation">info</summary>
            <aside>
               <p>
                  Just to simplify the notation, we've distributed the negation inside of the dot product operation. Remember that <lu-math data-inline>(<var>A</var> &bullet; <nobr><var>B</var>)<var>c</var></nobr> = <var>A</var><var>c</var> &bullet; <var>B</var><var>c</var></lu-math>.
               </p>
               <p>
                  It's pretty easy to miss, so note that where we were subtracting vectors, the order of the subtraction has changed: <lu-math data-inline>-(<var>a</var> - <var>b</var>) = <var>b</var> - <var>a</var></lu-math>.
               </p>
            </aside>
         </details>
         <m-content>
            (<var>H<sub>s</sub></var> - <var>H<sub>p</sub></var>)
            &bullet;
            -<var>C<sub>a</sub></var><var>C<sub>r</sub></var>
            = 0
         </m-content>
      </m-solvestep>
   </lu-math>
   <p>
      Now, let's expand {{var_Hs_inl}}. Maybe we'll be able to simplify further after that. Even if we can't, expanding that variable is still a necessary step to be able to plug our ray equation in.
   </p>
   <lu-math>
      <m-solvestep>
         <m-content>
            (<!--
            -->(<!--
               -->(<var>H<sub>p</sub></var> - <var>C<sub>b</sub></var>)
                  &bullet;
                  <var>C<sub>a</sub></var><!--
            -->)<var>C<sub>a</sub></var>
               +
               <var>C<sub>b</sub></var>
               -
               <var>H<sub>p</sub></var><!--
         -->)
            &bullet;
            -<var>C<sub>a</sub></var><var>C<sub>r</sub></var>
            = 0
         </m-content>
      </m-solvestep>
   </lu-math>
   <p>
      Hm. I can actually see some opportunities in there.
   </p>
   <lu-math>
      <m-solvestep>
         <m-content>
            (<!--
            -->(<!--
               -->(<mark><var>C<sub>a</sub></var> &bullet; {{dont_eat_this_space}}</mark><var>H<sub>p</sub></var>)
                  -
                  (<mark><var>C<sub>a</sub></var> &bullet; {{dont_eat_this_space}}</mark><var>C<sub>b</sub></var>)<!--
            -->)<var>C<sub>a</sub></var>
               +
               <var>C<sub>b</sub></var>
               -
               <var>H<sub>p</sub></var><!--
         -->)
            &bullet;
            -<var>C<sub>a</sub></var><var>C<sub>r</sub></var>
            = 0
         </m-content>
      </m-solvestep>
      <m-solvestep>
         <m-content>
            (<!--
            -->(<!--
               -->(<var>C<sub>a</sub></var> &bullet; <var>H<sub>p</sub></var>)
                  -
                  (<var>C<sub>a</sub></var> &bullet; <var>C<sub>b</sub></var>)<!--
            -->)<var>C<sub>a</sub></var><!--
            --><mark>{{dont_eat_this_space}} &bullet;
               -<var>C<sub>a</sub></var><var>C<sub>r</sub></var></mark><!--
         -->)
            +
            (<!--
            --><var>C<sub>b</sub></var><!--
            --><mark>{{dont_eat_this_space}} &bullet;
               -<var>C<sub>a</sub></var><var>C<sub>r</sub></var></mark><!--
         -->)
            -
            (<!--
            --><var>H<sub>p</sub></var><!--
            --><mark>{{dont_eat_this_space}} &bullet;
               -<var>C<sub>a</sub></var><var>C<sub>r</sub></var></mark><!--
         -->)
            = 0
         </m-content>
      </m-solvestep>
      <m-solvestep>
         {{lu_math_eq_numbers[6]}}
         
         <details class="explanation">
            <summary class="toggle-explanation">info</summary>
            <aside>
               We're taking the dot product of several vectors by another vector, which is negated. We can distribute the multiplication by -1, which has the effect of flipping signs all over the place.
            </aside>
         </details>
         <m-content>
            (<!--
            --><var>H<sub>p</sub></var>
               &bullet;
               <var>C<sub>a</sub></var><var>C<sub>r</sub></var><!--
         -->)<!--
         --><mark>{{dont_eat_this_space}} - {{dont_eat_this_space}} </mark><!--
         -->(<!--
            -->(<!--
               -->(<var>C<sub>a</sub></var> &bullet; <var>H<sub>p</sub></var>)
                  -
                  (<var>C<sub>a</sub></var> &bullet; <var>C<sub>b</sub></var>)<!--
            -->)<var>C<sub>a</sub></var>
               &bullet;
               <var>C<sub>a</sub></var><var>C<sub>r</sub></var><!--
         -->)<!--
         --><mark>{{dont_eat_this_space}} - {{dont_eat_this_space}} </mark><!--
         -->(<!--
            --><var>C<sub>b</sub></var>
               &bullet;
               <var>C<sub>a</sub></var><var>C<sub>r</sub></var><!--
         -->)
            = 0
         </m-content>
      </m-solvestep>
   </lu-math>
   <p>
      That's pretty bulky, but we may be able to simplify it down further once we substitute in the equation for our ray.
   </p>
</section>

<section>
   <h2><a name="solving">Solving for the ray</a></h2>
   <p>
      A ray is commonly defined in terms of a starting point, or <dfn>origin</dfn>, and a normalized direction vector. We can therefore define the hit position in terms of the same.
   </p>
   <lu-math>
      <m-givens>
         <label>Given:</label>
         <dl>
            <dt><var>R<sub>o</sub></var></dt>
            <m-sep> = </m-sep>
               <dd>the ray's origin</dd>
            <dt><var>R<sub>d</sub></var></dt>
            <m-sep> = </m-sep>
               <dd>the ray's direction</dd>
            <dt><var>H<sub>p</sub></var></dt>
            <m-sep> = </m-sep>
               <dd>the position at which the ray hits some surface</dd>
            <dt><var>H<sub>d</sub></var></dt>
            <m-sep> = </m-sep>
               <dd>the hit distance: the distance from the ray origin to the hit position</dd>
         </dl>
      </m-givens>
      <m-row>
         <var>H<sub>p</sub></var><!--
      -->&nbsp;=&nbsp;<!--
      --><var>R<sub>o</sub></var> + <var>R<sub>d</sub></var><var>H<sub>d</sub></var>
      </m-row>
   </lu-math>
   <p>
      We can substitute this equation into our cylinder equation above, and then attempt to solve for the hit distance {{var_Hd_inl}}:
   </p>
   
   <!-- CONTINUE FROM HERE -->
   <!--
      IF THIS DOESN'T WORK, TRY BACKING UP TO BEFORE WE STRIPPED OUT THE CROSS PRODUCT. 
      WE COULD ATTEMPT TO SUBSTITUTE THE RAY IN RIGHT AT THAT POINT, AND ONLY SIMPLIFY 
      THE CROSS PRODUCT OUT AFTERWARD.
   -->
</section>