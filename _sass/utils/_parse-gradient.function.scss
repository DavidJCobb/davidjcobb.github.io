
@import "polyfills/map-set.scss";
@import "utils/cast-to-color.scss";
@import "utils/cast-to-number.scss";
@import "utils/remove-unit.function.scss";
@import "utils/str-starts-with.function.scss";
@import "utils/str-ends-with.function.scss";
@import "utils/str-trim.function.scss";

@import "./gradient-functions/fix-gradient-stop-list.scss";
@import "./gradient-functions/linear-gradient-side-or-corner-to-angle.scss";

///
///   parse-gradient
///
///      Given a string, creates a map containing the gradient's properties. Properties 
///      of the map:
///
///       - type
///            The unquoted strings "linear" or "radial".
///
///       - stops
///            List of color stops. Each is a list of two values: the color and offset. 
///            Always present.
///
///       - angle
///            Present for linear-gradients that use an angle.
///
///       - side-or-corner
///            For linear gradients using "to <side-or-corner>", it's, um, that.
///
///       - shape
///            For radial gradients. May be absent.
///
///       - size
///            For radial gradients.
///
///       - pos
///            For radial gradients.
///
///      Returns an empty map on failure.
///
///      Note that gradient CSS values are strings in Sass.
///
@function parse-gradient($gradient) {
   $result:    ();
   $grad-type: null;
   
   $gradient: str-trim-start($gradient);
   
   $i: null;
   @if str-starts-with($gradient, unquote("linear-gradient(")) {
      $grad-type: unquote("linear");
      $i:         str-length("linear-gradient(");
   } @else if str-starts-with($gradient, unquote("radial-gradient(")) {
      $grad-type: unquote("radial");
      $i:         str-length("radial-gradient(");
   } @else {
      @return $result;
   }
   $result:   map-set($result, "type", $grad-type);
   $gradient: str-trim-start(str-slice($gradient, $i + 1));
   
   $stops: ();
   
   @if $grad-type == linear {
      @if str-starts-with($gradient, unquote("to ")) { // side-or-corner
         $gradient: str-slice($gradient, str-length(unquote("to ")));
         $i:        str-index($gradient, unquote(","));
         
         $side-or-corner: str-trim(str-slice($gradient, 1, $i - 1));
         $result:         map-set($result, "side-or-corner", $side-or-corner);
      } @else {
         $i: str-index($gradient, unquote(","));
         
         $angle:  str-trim(str-slice($gradient, 1, $i - 1));
         $result: map-set($result, "angle", $angle);
      }
      $gradient: str-slice($gradient, $i + 1);
   } @else if $grad-type == radial {
      $i: str-index($gradient, unquote(","));
      
      $shape-size-and-pos: str-trim-start(str-slice($gradient, 1, $i - 1));
      $gradient: str-slice($gradient, $i + 1);
      
      $shape-size-and-pos: str-split($shape-size-and-pos, " ");
      
      $shape: null;
      $size:  ();
      $pos:   ();
      
      $remaining:  ();
      $i:          1;
      $at-count:   null;
      $after-at:   false;
      $after-size: false;
      @while $i <= length($shape-size-and-pos) {
         $item: nth($shape-size-and-pos, $i);
         @if $item == "circle" or $item == "ellipse" {
            $shape:    $item;
            @if length($size) > 0 {
               $after-size: true;
            }
            @if $at-count != null {
               $after-at: true;
               $at-count: null;
            }
         } @else if $item == "at" {
            @if not $after-at {
               $at-count: 2;
               @if length($size) > 0 {
                  $after-size: true;
               }
            }
         } @else {
            @if $at-count != null {
               $pos:      append($pos, $item);
               $at-count: $at-count - 1;
               @if $at-count <= 0 {
                  $at-count: null;
               }
            }
            @if not $after-size {
               $size: append($size, $item);
               @if
                  length($size) == 2
               or $item == "closest-corner"
               or $item == "closest-side"
               or $item == "farthest-corner"
               or $item == "farthest-side"
               {
                  $after-size: true;
               }
            }
         }
         $i: $i + 1;
      }
      
      $len: length($size);
      @if $len > 0 {
         @if $len == 1 {
            @if $shape == null {
               $shape: "circle";
            }
            $item: nth($size, 1);
            @if $item == "closest-corner"
            or  $item == "closest-side"
            or  $item == "farthest-corner"
            or  $item == "farthest-side" {
               $result: map-set($result, "size", $item);
            } @else {
               $result: map-set($result, "size", join($size, $size));
            }
         } @else {
            @if $shape == null {
               $shape: "ellipse";
            }
            $result: map-set($result, "size", $size);
         }
      } @else {
         $result: map-set($result, "size", "farthest-corner");
         $shape:  "circle";
      }
      $result: map-set($result, "shape", $shape);
      
      $len: length($pos);
      @if $len > 0 {
         @if $len == 1 {
            $result: map-set($result, "pos", join($pos, $pos));
         } @else {
            $result: map-set($result, "pos", $pos);
         }
      }
   }
   
   $raw-stops: str-split($gradient, ",");
   $last-raw:  str-trim-end(nth($raw-stops, length($raw-stops)));
   @if str-ends-with($last-raw, unquote(")")) {
      $last-raw:  str-slice($last-raw, 1, str-length($last-raw) - 1);
      $raw-stops: set-nth($raw-stops, length($raw-stops), $last-raw);
   }
   
   $i: 1;
   @while $i <= length($raw-stops) {
      $stop: str-trim(nth($raw-stops, $i));
      $stop: str-split($stop, " ", 3);
      @if length($stop) == 1 {
         $stop:  (nth($stop, 1), null);
      } @else if length($stop) == 3 {
         $hint:  (nth($stop, 1) , nth($stop , 2));
         $stop:  (nth($stop, 1) , nth($stop , 3));
         $stops: append($stops, $stop);
         $stop:  $hint;
      }
      $stops: append($stops, $stop);
      
      $i: $i + 1;
   }
   $stops: fix-gradient-stop-list($stops);
   
   $result: map-set($result, "stops", $stops);
   @return $result;
}