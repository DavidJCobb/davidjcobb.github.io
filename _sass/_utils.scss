
/* polyfills: */

@function map-set($map, $key, $value) {
   @return map-merge($map, ($key: $value));
}

/* near-polyfills: */

@function list-prepend($list, $item) {
   $result: ();
   $result: append($result, $item);
   @each $prior in $list {
      $result: append($result, $prior);
   }
   @return $result;
}

/* custom: */

@function apply-all-to($properties, $list) {
   $result: ();
   @each $item in $list {
      $result: append($result, map-merge($item, $properties), comma);
   }
   @return $result
}

@function remove-unit($number) {
   @if type-of($number) == "number" and not unitless($number) {
      @return $number / ($number * 0 + 1);
   }
   @return $number;
}

@function text-shadows-for-outline($color) {
   $text-shadows: ();
   @for $x from -1 through 1 {
      @for $y from -1 through 1 {
         @if $x != 0 or $y != 0 {
            $text-shadows: append(
               $text-shadows,
               #{$x * 2}px #{$y * 2}px 1px #{$color},
               comma
            );
         }
      }
   }
   @return $text-shadows;
}

@function unpack-backgrounds($list) {
   $result: ();
   
   $properties-defaults: (
      "attach":   "scroll",
      "position": "left top",
      "repeat":   "repeat",
      "size":     "auto",
   );
   
   $properties-present: ();
   @each $key, $default in $properties-defaults {
      $properties-present: map-set($properties-present, $key, false);
   }
   @each $item in $list {
      @each $key, $default in $properties-defaults {
         @if map-has-key($item, $key) {
            $properties-present: map-set($properties-present, $key, true);
            /*
               Background-size cannot be specified in bulk without background-position.
            */
            @if $key == "size" {
               $properties-present: map-set($properties-present, "position", true);
            }
         }
      }
   }
   
   @each $item in $list {
      $entry: "";
      @if map-has-key($item, "attach") {
         $entry: $entry + " " + map-get($item, "attach");
      }
      
      @if map-has-key($item, "position") {
         $entry: $entry + " " + map-get($item, "position");
         @if map-has-key($item, "size") {
            $entry: $entry + "/" + map-get($item, "size");
         }
      } @else if map-has-key($item, "size") {
         $entry: $entry + " left top/" + map-get($item, "size");
      }
      
      @if map-has-key($item, "image") {
         $entry: $entry + " " + map-get($item, "image");
      }
      
      $result: append(
         $result,
         unquote($entry),
         comma
      );
   }
   @return $result;
}

@function wrap-items-in-key($key, $list...) {
   $result: ();
   @each $item in $list {
      $result: append($result, (
         $key: quote($item)
      ));
   }
   @return $result
}

/*
   Mixins
*/

/* Use inside of a table. */
@mixin table-top-left-cell {
   &>tr,
   &>:is(thead, tbody)>tr {
      &:first-child>:is(th, td):first-child {
         @content;
      }
   }
}
@mixin table-top-right-cell {
   >tr,
   >:is(thead, tbody)>tr {
      &:first-child>:is(th, td):last-child {
         @content;
      }
   }
}
@mixin table-bottom-left-cell {
   &>tr,
   &>:is(thead, tbody)>tr {
      &:last-child>:is(th, td):first-child {
         @content;
      }
   }
}
@mixin table-bottom-right-cell {
   >tr,
   >:is(thead, tbody)>tr {
      &:last-child>:is(th, td):last-child {
         @content;
      }
   }
}
@mixin table-corner-left-cells {
   &>tr,
   &>:is(thead, tbody)>tr {
      &:first-child,
      &:last-child {
         >:is(th, td):first-child {
            @content;
         }
      }
   }
}
@mixin table-corner-right-cells {
   &>tr,
   &>:is(thead, tbody)>tr {
      &:first-child,
      &:last-child {
         >:is(th, td):last-child {
            @content;
         }
      }
   }
}

/* Use inside of a table. */
@mixin border-collapse {
   /*
      The CSS spec says that border-collapse completely nullifies border-radius. Apparently, 
      CSS 2.1 had spec'd out a reasonable behavior, but because browsers didn't bother to 
      implement it, the CSSWG just spiked it outright "for interop:"
      
         https://github.com/w3c/csswg-drafts/issues/475
         
      So now, we need ugly hacks for rounded collapsing borders.
   */
   
   border-collapse:separate;
   border-spacing:0;
   
   /* TODO: Do browsers always force-wrap table content in TBODY if unwrapped? If so, we 
            can simplify the selectors here */
   
   /*
      Cheap hack to account for rowSpan: prevent it from overflowing the rounded corner 
      (can't really make it collapse its bottom border, though):
   */
   clip-path:inset(0 0 0 0 round 1em);
   /*
      Note that we actually can't emulate border-collapse for tables with rowSpan, because 
      if some row R begins with a rowSpan > 1 cell, rows below R can no longer rely on the 
      :first-child pseudo-class to identify cells on the left edge of the table.  The rows 
      below R will have their cells inset by the rowSpan'd cell in R: the first TD/TH node 
      in these rows will actually represent the cell in the second column.
      
      Similar issues exist with the rightmost column.
   */
   
   $-cell: ":is(td, th)";
   $-part: ":is(thead, tbody)";
   
   /*
      Forward table border-radius to cells:
   */
   >:is(tr, thead, tbody),
   >#{$-part}>tr {
      &:first-child {
         border-top-left-radius:inherit;
         border-top-right-radius:inherit;
      }
      &:last-child {
         border-bottom-left-radius:inherit;
         border-bottom-right-radius:inherit;
      }
   }
   >tr,
   >#{$-part}>tr {
      /*
         Use :where() to lower specificity.
      */
      @at-root :where(#{&})>#{$-cell}:first-child {
         border-top-left-radius:inherit;
         border-bottom-left-radius:inherit;
      }
      @at-root :where(#{&})>#{$-cell}:last-child {
         border-top-right-radius:inherit;
         border-bottom-right-radius:inherit;
      }
   }
   
   /*
      Collapse borders between the table and the cells, preferring the table:
   */
   >tr,
   >:is(thead, tbody)>tr {
      >:is(td, th) {
         &:first-child {
            border-left-width:0!important;
         }
         &:last-child {
            border-right-width:0!important;
         }
      }
   }
   
   $-h-border-tc1: ">tr:whichever-child>#{$-cell}";
   $-h-border-tc2: ">#{$-part}:whichever-child#{$-h-border-tc1}";

   #{selector-replace($-h-border-tc1, ":whichever-child", ":first-child")},
   #{selector-replace($-h-border-tc2, ":whichever-child", ":first-child")} {
      border-top-width:0!important;
   }
   
   #{selector-replace($-h-border-tc1, ":whichever-child", ":last-child")},
   #{selector-replace($-h-border-tc2, ":whichever-child", ":last-child")} {
      border-bottom-width:0!important;
   }
   
   /* needed to account for rowSpan */
   :is(td, th).force-is-bottom-row {
      border-bottom-width:0!important;
   }
   
   /*
      Collapse borders between cells:
   */
   >tr,
   >#{$-part}>tr {
      >#{$-cell}+#{$-cell} {
         border-left-width:0!important;
      }
   }
   >tr+tr,
   >#{$-part}>tr+tr,
   >#{$-part}+#{$-part}>tr {
      >#{$-cell} {
         border-top-width:0!important;
      }
   }
}

@mixin for-firefox-only {
   @-moz-document url-prefix() {
      @content;
   }
}
@mixin exclude-firefox {
   @supports (text-size-adjust: none) or (text-decoration-skip: none) {
      @content;
   }
}

/*
   styles for smartphones. there's no good query for these, so we have 
   to go with:
   
    - device has a screen
    - device does not have a pointer that can "hover" over things
    - maximum aspect ratio ensures we only affect portrait orientation
    
*/
@mixin for-smartphones-only {
   @media only screen and (any-hover: none) and (pointer: coarse),
          only screen and (any-hover: none) and (pointer: none) {
      @content;
   }
}
@mixin for-smartphones-only-portrait {
   @media only screen and (any-hover: none) and (pointer: coarse) and (max-aspect-ratio:3/5),
          only screen and (any-hover: none) and (pointer: none)   and (max-aspect-ratio:3/5) {
      @content;
   }
}

@mixin screen-reader {
   position:absolute;
   left:-100vw;
   top:auto;
   width:1px;
   height:1px;
}